/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2018-11-07 17:43:53.820008
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp

//// START
//// Make sure the version number matches.
//// You might need to install the dev version to get the header files.
//// sudo apt-get install python3.4-dev
#include "Python.h"
//// END

#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64,x65,x66,x67,x68,x69,x70;
x0=IKcos(j[1]);
x1=IKcos(j[4]);
x2=IKcos(j[2]);
x3=IKsin(j[4]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKsin(j[6]);
x9=IKcos(j[6]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=IKcos(j[7]);
x13=IKsin(j[7]);
x14=((0.987227247014917)*x12);
x15=((1.0)*x3);
x16=((0.159318431925963)*x13);
x17=((0.2156)*x10);
x18=((0.987227247014917)*x13);
x19=((1.0)*x8);
x20=((0.321)*x1);
x21=((1.0)*x6);
x22=((0.321)*x5);
x23=((1.0)*x9);
x24=((0.2156)*x3);
x25=((0.159318431925963)*x12);
x26=((1.0)*x1);
x27=((0.2156)*x11);
x28=((0.2156)*x1);
x29=((0.321)*x6);
x30=(x2*x7);
x31=((-1.0)*x8);
x32=(x2*x5);
x33=(x0*x4);
x34=((-1.0)*x9);
x35=(x2*x6);
x36=(x0*x2);
x37=(x5*x7);
x38=(x4*x7);
x39=((-1.0)*x3);
x40=((-1.0)*x36);
x41=(x15*x36);
x42=(x15*x30);
x43=(x1*x2*x21);
x44=((((-1.0)*x21*x7))+((x33*x5)));
x45=(((x0*x5))+(((-1.0)*x21*x38)));
x46=(((x0*x6))+((x37*x4)));
x47=((((-1.0)*x43))+((x3*x4)));
x48=((((-1.0)*x37))+(((-1.0)*x21*x33)));
x49=(x11*x44);
x50=(x1*x45);
x51=(((x15*x35))+((x26*x4)));
x52=(x11*x46);
x53=(x1*x48);
x54=(((x10*x47))+((x11*x32)));
x55=(((x10*x32))+((x11*((x43+(((-1.0)*x15*x4)))))));
x56=((((-1.0)*x41))+x53);
x57=((((-1.0)*x15*x45))+(((-1.0)*x26*x30)));
x58=(x57*x8);
x59=(((x39*x48))+((x1*x40)));
x60=(((x10*((x50+((x30*x39))))))+x52);
x61=(((x11*((x42+(((-1.0)*x50))))))+((x10*x46)));
x62=(((x51*x8))+((x54*x9)));
x63=(((x10*((((x36*x39))+x53))))+x49);
x64=(((x10*x44))+((x11*((x41+(((-1.0)*x26*x48)))))));
x65=(x60*x9);
x66=(x63*x9);
x67=(x58+x65);
x68=((((-1.0)*x23*x60))+(((-1.0)*x19*x57)));
x69=(x66+((x59*x8)));
x70=(((x34*x63))+((x31*x59)));
eerot[0]=(((x8*((((x10*x56))+x49))))+((x9*((((x3*x48))+((x1*x36)))))));
eerot[1]=((((-1.0)*x25*x69))+((x14*x64))+((x18*x70))+(((-1.0)*x16*x64)));
IkReal x72=((1.0)*x64);
eerot[2]=((((-1.0)*x25*x72))+(((-1.0)*x18*x72))+(((-1.0)*x16*x70))+(((-1.0)*x14*x69)));
eetrans[0]=((-0.05)+((x20*x36))+(((0.1)*x0))+((x8*((((x27*x44))+((x17*x56))))))+((x9*((((x28*x36))+((x24*x48))))))+((x3*(((((-1.0)*x29*x33))+(((-1.0)*x22*x7))))))+(((0.4)*x36)));
eerot[3]=(((x60*x8))+((x9*((((x3*x45))+((x1*x30)))))));
eerot[4]=((((-1.0)*x25*x67))+((x14*x61))+((x18*x68))+(((-1.0)*x16*x61)));
IkReal x73=((1.0)*x61);
eerot[5]=((((-1.0)*x25*x73))+(((-1.0)*x18*x73))+(((-1.0)*x16*x68))+(((-1.0)*x14*x67)));
eetrans[1]=((-0.188)+((x8*((((x27*x46))+((x17*(((((-1.0)*x42))+x50))))))))+((x3*((((x0*x22))+(((-1.0)*x29*x38))))))+((x20*x30))+(((0.1)*x7))+((x9*((((x28*x30))+((x24*x45))))))+(((0.4)*x30)));
eerot[6]=((((-1.0)*x51*x9))+((x54*x8)));
eerot[7]=((((-1.0)*x25*x62))+((x14*x55))+(((-1.0)*x16*x55))+((x18*((((x34*x54))+((x31*x51)))))));
IkReal x74=((1.0)*x55);
eerot[8]=((((-1.0)*x25*x74))+(((-1.0)*x18*x74))+(((-1.0)*x14*x62))+(((-1.0)*x16*(((((-1.0)*x23*x54))+(((-1.0)*x19*x51)))))));
IkReal x75=((1.0)*x4);
eetrans[2]=((0.739675)+((x8*((((x27*x32))+((x17*x47))))))+(((-1.0)*x2*x29*x3))+(((-1.0)*x20*x75))+((x9*(((((-1.0)*x24*x35))+(((-1.0)*x28*x75))))))+(((-0.4)*x4))+j[0]);
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j12,cj12,sj12,htj12,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij12[2], _nj12,_ij29[2], _nj29;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]), htj12=tan(pfree[0]*0.5);
j29=pfree[1]; cj29=cos(pfree[1]); sj29=sin(pfree[1]), htj29=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((((-0.987227247014917)*r02))+(((-0.159318431925963)*r01)));
new_r01=((((0.987227247014917)*r01))+(((-0.159318431925963)*r02)));
new_r02=r00;
new_px=((0.05)+(((-0.2156)*r00))+px);
new_r10=((((-0.987227247014917)*r12))+(((-0.159318431925963)*r11)));
new_r11=((((0.987227247014917)*r11))+(((-0.159318431925963)*r12)));
new_r12=r10;
new_py=((0.188)+(((-0.2156)*r10))+py);
new_r20=((((-0.987227247014917)*r22))+(((-0.159318431925963)*r21)));
new_r21=((((0.987227247014917)*r21))+(((-0.159318431925963)*r22)));
new_r22=r20;
new_pz=((-0.739675)+(((-1.0)*j12))+(((-0.2156)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x76=((1.0)*px);
IkReal x77=((1.0)*pz);
IkReal x78=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x78))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x77)));
rxp0_2=((((-1.0)*r10*x76))+((py*r00)));
rxp1_0=((((-1.0)*r21*x78))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x77)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x76)));
rxp2_0=((((-1.0)*r22*x78))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x77)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x76)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x79=((0.2)*px);
IkReal x80=((1.0)*pp);
IkReal x81=((0.509841)+x79+(((-1.0)*x80)));
IkReal x82=((-0.003759)+x79+(((-1.0)*x80)));
IkReal x83=(x79+x80);
IkReal x84=((0.509841)+(((-1.0)*x83)));
IkReal x85=((-0.003759)+(((-1.0)*x83)));
IkReal gconst0=x81;
IkReal gconst1=x82;
IkReal gconst2=x81;
IkReal gconst3=x82;
IkReal gconst4=x84;
IkReal gconst5=x85;
IkReal gconst6=x84;
IkReal gconst7=x85;
IkReal x86=py*py;
IkReal x87=sj29*sj29;
IkReal x88=px*px;
IkReal x89=((1.0)*gconst4);
IkReal x90=(gconst5*gconst7);
IkReal x91=(gconst0*gconst3);
IkReal x92=(gconst1*gconst2);
IkReal x93=((2.0)*gconst5);
IkReal x94=((1.0)*gconst0);
IkReal x95=(gconst1*gconst7);
IkReal x96=(gconst0*gconst6);
IkReal x97=(gconst1*gconst3);
IkReal x98=(gconst4*gconst7);
IkReal x99=((2.0)*gconst0);
IkReal x100=(gconst1*gconst6);
IkReal x101=(gconst0*gconst7);
IkReal x102=((2.0)*gconst4);
IkReal x103=(gconst3*gconst5);
IkReal x104=(gconst2*gconst5);
IkReal x105=(gconst3*gconst4);
IkReal x106=(gconst2*gconst4);
IkReal x107=(gconst4*gconst6);
IkReal x108=(gconst5*gconst6);
IkReal x109=(gconst0*gconst2);
IkReal x110=((1.05513984)*px*py);
IkReal x111=(gconst6*x86);
IkReal x112=((4.0)*px*py);
IkReal x113=((4.0)*x88);
IkReal x114=(gconst2*x86);
IkReal x115=(py*x87);
IkReal x116=((2.0)*x86);
IkReal x117=((1.0)*x86);
IkReal x118=((0.824328)*x87);
IkReal x119=((0.412164)*x87);
IkReal x120=(x86*x98);
IkReal x121=(x108*x86);
IkReal x122=(x104*x86);
IkReal x123=(x105*x86);
IkReal x124=(x101*x86);
IkReal x125=(x100*x86);
IkReal x126=((0.0834355125792)*x115);
IkReal x127=(x86*x92);
IkReal x128=(x86*x91);
IkReal x130=(x86*x87);
IkReal x131=(x117*x90);
IkReal x132=(x111*x89);
IkReal x133=(x108*x119);
IkReal x134=(x106*x112);
IkReal x135=(x112*x95);
IkReal x136=(x103*x112);
IkReal x137=(x112*x96);
IkReal x138=(x105*x112);
IkReal x139=(x101*x112);
IkReal x140=(x104*x112);
IkReal x141=(x100*x112);
IkReal x142=(x104*x119);
IkReal x143=((0.06594624)*x130);
IkReal x144=(x117*x95);
IkReal x145=(x114*x89);
IkReal x146=(x111*x94);
IkReal x147=(x100*x119);
IkReal x148=(x103*x117);
IkReal x149=((0.3297312)*pp*x115);
IkReal x150=((0.06594624)*px*x115);
IkReal x151=(x114*x94);
IkReal x152=(x119*x92);
IkReal x153=(x117*x97);
IkReal x154=(x127+x128);
IkReal x155=(x120+x121);
IkReal x156=(x153+x152+x151);
IkReal x157=(x131+x133+x132);
IkReal x158=(x124+x125+x122+x123);
IkReal x159=(x140+x141+x139+x138);
IkReal x160=(x135+x134+x137+x136);
IkReal x161=(x142+x143+x144+x145+x146+x147+x148);
op[0]=((((-1.0)*x157))+x155);
op[1]=((((-1.0)*x110))+(((-1.0)*x126))+x150+x149);
op[2]=(((x113*x98))+(((-1.0)*x161))+(((-1.0)*x113*x90))+(((-1.0)*x107*x113))+((x102*x111))+x158+(((-1.0)*x111*x93))+(((-1.0)*x108*x118))+((x108*x113))+(((-1.0)*x116*x98))+((x116*x90)));
op[3]=((((-0.1648656)*gconst2*x115))+(((-1.0)*x160))+(((-0.1648656)*gconst1*x115))+(((-0.3297312)*gconst5*x115))+x159+(((-1.0)*x112*x98))+(((-1.0)*x108*x112))+((x112*x90))+(((-0.3297312)*gconst6*x115))+((x107*x112)));
op[4]=((((-1.0)*x114*x93))+((x100*x113))+(((-1.0)*x157))+(((-1.0)*x156))+(((-0.13189248)*x130))+(((-1.0)*x100*x118))+(((-1.0)*x100*x116))+(((-1.0)*x113*x96))+(((-1.0)*x113*x95))+((x102*x114))+((gconst3*x86*x93))+x155+x154+(((-1.0)*gconst3*x102*x86))+(((-1.0)*x106*x113))+((x104*x113))+(((-1.0)*gconst7*x86*x99))+((x105*x113))+(((-1.0)*x103*x113))+((x101*x113))+((x116*x96))+((x116*x95))+(((-1.0)*x104*x118)));
op[5]=((((-0.3297312)*gconst2*x115))+(((-1.0)*x159))+x160+(((-0.1648656)*gconst5*x115))+(((-1.0)*x112*x97))+(((-1.0)*x109*x112))+(((-0.1648656)*gconst6*x115))+((x112*x92))+((x112*x91))+(((-0.3297312)*gconst1*x115)));
op[6]=(((x113*x91))+((x113*x92))+(((-1.0)*x161))+(((-1.0)*x113*x97))+((x114*x99))+(((-1.0)*x118*x92))+x158+(((-1.0)*x109*x113))+(((-1.0)*x116*x91))+(((-1.0)*x116*x92))+((x116*x97)));
op[7]=((((-1.0)*x150))+(((-1.0)*x126))+x149+x110);
op[8]=((((-1.0)*x156))+x154);
polyroots8(op,zeror,numroots);
IkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];
int numsolutions = 0;
for(int ij27 = 0; ij27 < numroots; ++ij27)
{
IkReal htj27 = zeror[ij27];
tempj27array[0]=((2.0)*(atan(htj27)));
for(int kj27 = 0; kj27 < 1; ++kj27)
{
j27array[numsolutions] = tempj27array[kj27];
if( j27array[numsolutions] > IKPI )
{
    j27array[numsolutions]-=IK2PI;
}
else if( j27array[numsolutions] < -IKPI )
{
    j27array[numsolutions]+=IK2PI;
}
sj27array[numsolutions] = IKsin(j27array[numsolutions]);
cj27array[numsolutions] = IKcos(j27array[numsolutions]);
numsolutions++;
}
}
bool j27valid[8]={true,true,true,true,true,true,true,true};
_nj27 = 8;
for(int ij27 = 0; ij27 < numsolutions; ++ij27)
    {
if( !j27valid[ij27] )
{
    continue;
}
    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];
htj27 = IKtan(j27/2);

_ij27[0] = ij27; _ij27[1] = -1;
for(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)
{
if( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )
{
    j27valid[iij27]=false; _ij27[1] = iij27; break; 
}
}
{
IkReal j28eval[2];
IkReal x162=cj27*cj27;
IkReal x163=py*py;
IkReal x164=px*px;
IkReal x165=pz*pz;
IkReal x166=((100.0)*sj29);
IkReal x167=(py*sj27);
IkReal x168=((4.0)*sj29);
IkReal x169=(cj27*px*sj29);
IkReal x170=(x162*x164);
IkReal x171=(x163*x168);
j28eval[0]=((((-200.0)*x167*x169))+(((-1.0)*x163*x166))+(((20.0)*x169))+(((-1.0)*sj29))+((x162*x163*x166))+(((20.0)*sj29*x167))+(((-1.0)*x165*x166))+(((-1.0)*x166*x170)));
j28eval[1]=IKsign((((x162*x171))+(((-8.0)*x167*x169))+(((-1.0)*x171))+(((0.8)*x169))+(((-0.04)*sj29))+(((-1.0)*x168*x170))+(((-1.0)*x165*x168))+(((0.8)*sj29*x167))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x172=((321000.0)*cj30);
IkReal x173=(py*sj27);
IkReal x174=((321000.0)*sj30);
IkReal x175=(cj27*px);
j28eval[0]=((1.02430295950156)+cj30);
j28eval[1]=((IKabs(((-40000.0)+(((400000.0)*x175))+(((400000.0)*x173))+(((-32100.0)*cj30))+(((-1.0)*pz*x174))+((x172*x175))+((x172*x173)))))+(IKabs(((((-1.0)*x174*x175))+(((32100.0)*sj30))+(((-1.0)*pz*x172))+(((-400000.0)*pz))+(((-1.0)*x173*x174))))));
j28eval[2]=IKsign(((263041.0)+(((256800.0)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x176=(pz*sj30);
IkReal x177=(cj27*px);
IkReal x178=(py*sj27);
IkReal x179=((10.0)*cj30);
IkReal x180=((321.0)*cj30);
IkReal x181=((1000.0)*pz);
j28eval[0]=((1.24610591900312)+(((-10.0)*x176))+(((-1.0)*x177*x179))+cj30+(((-1.0)*x178*x179))+(((-12.4610591900312)*x178))+(((-12.4610591900312)*x177)));
j28eval[1]=((IKabs(((-160.0)+((pz*x181))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30)))))+(IKabs((((x177*x181))+(((-100.0)*pz))+((x178*x181))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))));
j28eval[2]=IKsign(((40.0)+(((-1.0)*x178*x180))+(((-400.0)*x177))+(((-400.0)*x178))+(((-1.0)*x177*x180))+(((-321.0)*x176))+(((32.1)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x182=cj27*cj27;
IkReal x183=py*py;
IkReal x184=pz*pz;
IkReal x185=px*px;
IkReal x186=(cj27*px);
IkReal x187=((321.0)*sj30);
IkReal x188=(py*sj27);
IkReal x189=((321.0)*cj30);
IkReal x191=((200.0)*x188);
IkReal x192=(x182*x183);
IkReal x193=(x182*x185);
j28eval[0]=((-1.0)+(((-1.0)*x186*x191))+(((20.0)*x188))+(((20.0)*x186))+(((-100.0)*x184))+(((-100.0)*x183))+(((-100.0)*x193))+(((100.0)*x192)));
j28eval[1]=((IKabs(((40.0)+(((-1.0)*x188*x189))+((pz*x187))+(((-400.0)*x186))+(((-400.0)*x188))+(((-1.0)*x186*x189))+(((32.1)*cj30)))))+(IKabs((((pz*x189))+((x186*x187))+((x187*x188))+(((400.0)*pz))+(((-32.1)*sj30))))));
j28eval[2]=IKsign(((-10.0)+(((1000.0)*x192))+(((-2000.0)*x186*x188))+x191+(((-1000.0)*x184))+(((-1000.0)*x183))+(((-1000.0)*x193))+(((200.0)*x186))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x194=py*py;
IkReal x195=cj27*cj27;
IkReal x196=(cj27*px);
IkReal x197=(py*sj27);
IkReal x198=((321.0)*cj30);
IkReal x199=((321.0)*sj30);
IkReal x200=((1000.0)*x195);
CheckValue<IkReal> x201=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-2000.0)*x196*x197))+(((-1.0)*x200*(px*px)))+((x194*x200))+(((-1000.0)*(pz*pz)))+(((-1000.0)*x194))+(((200.0)*x197))+(((200.0)*x196)))),-1);
if(!x201.valid){
continue;
}
CheckValue<IkReal> x202 = IKatan2WithCheck(IkReal(((((400.0)*pz))+((x196*x199))+((x197*x199))+(((-32.1)*sj30))+((pz*x198)))),IkReal(((40.0)+(((-1.0)*x196*x198))+(((-400.0)*x197))+(((-400.0)*x196))+(((-1.0)*x197*x198))+(((32.1)*cj30))+((pz*x199)))),IKFAST_ATAN2_MAGTHRESH);
if(!x202.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x201.value)))+(x202.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x203=IKsin(j28);
IkReal x204=IKcos(j28);
IkReal x205=((0.321)*cj30);
IkReal x206=((0.321)*sj30);
IkReal x207=(cj27*px);
IkReal x208=(py*sj27);
IkReal x209=((1.0)*x208);
IkReal x210=(pz*x203);
IkReal x211=((0.8)*x204);
evalcond[0]=((((0.4)*x203))+((x204*x206))+pz+((x203*x205)));
evalcond[1]=((((-0.1)*x203))+((pz*x204))+x206+((x203*x208))+((x203*x207)));
evalcond[2]=((0.1)+(((-1.0)*x203*x206))+(((0.4)*x204))+(((-1.0)*x209))+((x204*x205))+(((-1.0)*x207)));
evalcond[3]=((0.4)+(((-1.0)*x204*x209))+x210+x205+(((-1.0)*x204*x207))+(((0.1)*x204)));
evalcond[4]=((-0.066959)+(((0.2)*x207))+(((0.2)*x208))+((x208*x211))+((x207*x211))+(((-0.8)*x210))+(((-1.0)*pp))+(((-0.08)*x204)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x677=((321.0)*cj30);
IkReal x678=(py*sj27);
IkReal x679=(cj27*px);
IkReal x680=((1000.0)*pz);
CheckValue<IkReal> x681=IKPowWithIntegerCheck(IKsign(((40.0)+(((-321.0)*pz*sj30))+(((-1.0)*x677*x679))+(((-1.0)*x677*x678))+(((32.1)*cj30))+(((-400.0)*x679))+(((-400.0)*x678)))),-1);
if(!x681.valid){
continue;
}
CheckValue<IkReal> x682 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+((x678*x680))+(((128.4)*sj30))+((x679*x680))+(((103.041)*cj30*sj30)))),IkReal(((-160.0)+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))+((pz*x680)))),IKFAST_ATAN2_MAGTHRESH);
if(!x682.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x681.value)))+(x682.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x683=IKsin(j28);
IkReal x684=IKcos(j28);
IkReal x685=((0.321)*cj30);
IkReal x686=((0.321)*sj30);
IkReal x687=(cj27*px);
IkReal x688=(py*sj27);
IkReal x689=((1.0)*x688);
IkReal x690=(pz*x683);
IkReal x691=((0.8)*x684);
evalcond[0]=(((x683*x685))+pz+(((0.4)*x683))+((x684*x686)));
evalcond[1]=((((-0.1)*x683))+((x683*x687))+((x683*x688))+x686+((pz*x684)));
evalcond[2]=((0.1)+(((-1.0)*x689))+(((0.4)*x684))+(((-1.0)*x683*x686))+((x684*x685))+(((-1.0)*x687)));
evalcond[3]=((0.4)+(((-1.0)*x684*x687))+(((-1.0)*x684*x689))+x685+x690+(((0.1)*x684)));
evalcond[4]=((-0.066959)+((x688*x691))+((x687*x691))+(((0.2)*x688))+(((0.2)*x687))+(((-0.08)*x684))+(((-1.0)*pp))+(((-0.8)*x690)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x692=((321000.0)*cj30);
IkReal x693=(py*sj27);
IkReal x694=(cj27*px);
IkReal x695=((321000.0)*sj30);
CheckValue<IkReal> x696 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*x693*x695))+(((-400000.0)*pz))+(((-1.0)*pz*x692))+(((-1.0)*x694*x695)))),IkReal(((-40000.0)+(((-32100.0)*cj30))+((x692*x694))+((x692*x693))+(((-1.0)*pz*x695))+(((400000.0)*x693))+(((400000.0)*x694)))),IKFAST_ATAN2_MAGTHRESH);
if(!x696.valid){
continue;
}
CheckValue<IkReal> x697=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj30)))),-1);
if(!x697.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x696.value)+(((1.5707963267949)*(x697.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x698=IKsin(j28);
IkReal x699=IKcos(j28);
IkReal x700=((0.321)*cj30);
IkReal x701=((0.321)*sj30);
IkReal x702=(cj27*px);
IkReal x703=(py*sj27);
IkReal x704=((1.0)*x703);
IkReal x705=(pz*x698);
IkReal x706=((0.8)*x699);
evalcond[0]=((((0.4)*x698))+pz+((x698*x700))+((x699*x701)));
evalcond[1]=(((pz*x699))+((x698*x702))+((x698*x703))+x701+(((-0.1)*x698)));
evalcond[2]=((0.1)+(((-1.0)*x702))+(((0.4)*x699))+(((-1.0)*x704))+(((-1.0)*x698*x701))+((x699*x700)));
evalcond[3]=((0.4)+(((0.1)*x699))+(((-1.0)*x699*x702))+(((-1.0)*x699*x704))+x700+x705);
evalcond[4]=((-0.066959)+((x702*x706))+((x703*x706))+(((-0.8)*x705))+(((-1.0)*pp))+(((-0.08)*x699))+(((0.2)*x702))+(((0.2)*x703)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x707=((321000.0)*cj30);
IkReal x708=(py*sj27);
IkReal x709=((321000.0)*sj30);
IkReal x710=(cj27*px);
j28eval[0]=((-1.02430295950156)+(((-1.0)*cj30)));
j28eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj30))));
j28eval[2]=((IKabs(((40000.0)+(((-1.0)*pz*x709))+(((-1.0)*x707*x708))+(((-1.0)*x707*x710))+(((-400000.0)*x710))+(((32100.0)*cj30))+(((-400000.0)*x708)))))+(IKabs(((((32100.0)*sj30))+(((-1.0)*x709*x710))+(((400000.0)*pz))+(((-1.0)*x708*x709))+((pz*x707))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x711=(pz*sj30);
IkReal x712=(cj27*px);
IkReal x713=(py*sj27);
IkReal x714=((10.0)*cj30);
IkReal x715=((1000.0)*pz);
IkReal x716=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+(((12.4610591900312)*x713))+(((12.4610591900312)*x712))+(((-10.0)*x711))+(((-1.0)*cj30))+((x712*x714))+((x713*x714)));
j28eval[1]=((IKabs(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x712*x715))+(((-1.0)*x713*x715))+(((103.041)*cj30*sj30)))))+(IKabs(((160.0)+(((-1.0)*pz*x715))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))))));
j28eval[2]=IKsign(((-40.0)+(((-321.0)*x711))+(((400.0)*x712))+(((400.0)*x713))+((x712*x716))+((x713*x716))+(((-32.1)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x717=cj27*cj27;
IkReal x718=py*py;
IkReal x719=pz*pz;
IkReal x720=px*px;
IkReal x721=(cj27*px);
IkReal x722=((321.0)*sj30);
IkReal x723=(py*sj27);
IkReal x724=((321.0)*cj30);
IkReal x726=((200.0)*x723);
IkReal x727=(x717*x718);
IkReal x728=(x717*x720);
j28eval[0]=((-1.0)+(((-100.0)*x728))+(((-100.0)*x719))+(((-100.0)*x718))+(((-1.0)*x721*x726))+(((20.0)*x721))+(((20.0)*x723))+(((100.0)*x727)));
j28eval[1]=((IKabs(((((400.0)*pz))+(((-1.0)*x722*x723))+(((32.1)*sj30))+(((-1.0)*x721*x722))+((pz*x724)))))+(IKabs(((40.0)+(((-1.0)*x723*x724))+(((-400.0)*x723))+(((-400.0)*x721))+(((-1.0)*x721*x724))+(((32.1)*cj30))+(((-1.0)*pz*x722))))));
j28eval[2]=IKsign(((-10.0)+(((200.0)*x721))+(((1000.0)*x727))+(((-1000.0)*x719))+(((-1000.0)*x718))+x726+(((-1000.0)*x728))+(((-2000.0)*x721*x723))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x729=py*py;
IkReal x730=cj27*cj27;
IkReal x731=(cj27*px);
IkReal x732=(py*sj27);
IkReal x733=((321.0)*cj30);
IkReal x734=((321.0)*sj30);
IkReal x735=((1000.0)*x730);
CheckValue<IkReal> x736 = IKatan2WithCheck(IkReal(((((-1.0)*x732*x734))+(((-1.0)*x731*x734))+(((400.0)*pz))+(((32.1)*sj30))+((pz*x733)))),IkReal(((40.0)+(((-1.0)*x732*x733))+(((-1.0)*x731*x733))+(((-400.0)*x731))+(((-400.0)*x732))+(((-1.0)*pz*x734))+(((32.1)*cj30)))),IKFAST_ATAN2_MAGTHRESH);
if(!x736.valid){
continue;
}
CheckValue<IkReal> x737=IKPowWithIntegerCheck(IKsign(((-10.0)+(((200.0)*x731))+(((200.0)*x732))+(((-2000.0)*x731*x732))+(((-1000.0)*(pz*pz)))+((x729*x735))+(((-1000.0)*x729))+(((-1.0)*x735*(px*px))))),-1);
if(!x737.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x736.value)+(((1.5707963267949)*(x737.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x738=IKsin(j28);
IkReal x739=IKcos(j28);
IkReal x740=((0.321)*cj30);
IkReal x741=((0.321)*sj30);
IkReal x742=(py*sj27);
IkReal x743=(cj27*px);
IkReal x744=((1.0)*x742);
IkReal x745=(pz*x738);
IkReal x746=((1.0)*x739);
IkReal x747=((0.8)*x739);
evalcond[0]=((((0.4)*x738))+((x738*x740))+pz+(((-1.0)*x739*x741)));
evalcond[1]=((0.1)+(((0.4)*x739))+((x738*x741))+((x739*x740))+(((-1.0)*x743))+(((-1.0)*x744)));
evalcond[2]=((0.4)+(((0.1)*x739))+x745+x740+(((-1.0)*x739*x744))+(((-1.0)*x743*x746)));
evalcond[3]=((((-1.0)*x738*x744))+(((-1.0)*pz*x746))+(((0.1)*x738))+x741+(((-1.0)*x738*x743)));
evalcond[4]=((-0.066959)+((x742*x747))+(((-0.08)*x739))+(((-1.0)*pp))+(((0.2)*x743))+(((0.2)*x742))+((x743*x747))+(((-0.8)*x745)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x748=((321.0)*cj30);
IkReal x749=(py*sj27);
IkReal x750=(cj27*px);
IkReal x751=((1000.0)*pz);
CheckValue<IkReal> x752 = IKatan2WithCheck(IkReal(((((-1.0)*x750*x751))+(((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x749*x751))+(((103.041)*cj30*sj30)))),IkReal(((160.0)+(((-1.0)*pz*x751))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))),IKFAST_ATAN2_MAGTHRESH);
if(!x752.valid){
continue;
}
CheckValue<IkReal> x753=IKPowWithIntegerCheck(IKsign(((-40.0)+(((-321.0)*pz*sj30))+(((400.0)*x749))+(((400.0)*x750))+((x748*x750))+(((-32.1)*cj30))+((x748*x749)))),-1);
if(!x753.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x752.value)+(((1.5707963267949)*(x753.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x754=IKsin(j28);
IkReal x755=IKcos(j28);
IkReal x756=((0.321)*cj30);
IkReal x757=((0.321)*sj30);
IkReal x758=(py*sj27);
IkReal x759=(cj27*px);
IkReal x760=((1.0)*x758);
IkReal x761=(pz*x754);
IkReal x762=((1.0)*x755);
IkReal x763=((0.8)*x755);
evalcond[0]=((((-1.0)*x755*x757))+pz+(((0.4)*x754))+((x754*x756)));
evalcond[1]=((0.1)+(((-1.0)*x760))+(((-1.0)*x759))+((x755*x756))+(((0.4)*x755))+((x754*x757)));
evalcond[2]=((0.4)+(((0.1)*x755))+(((-1.0)*x755*x760))+x756+x761+(((-1.0)*x759*x762)));
evalcond[3]=((((0.1)*x754))+(((-1.0)*x754*x760))+(((-1.0)*x754*x759))+x757+(((-1.0)*pz*x762)));
evalcond[4]=((-0.066959)+(((-0.08)*x755))+((x759*x763))+(((0.2)*x758))+(((0.2)*x759))+((x758*x763))+(((-1.0)*pp))+(((-0.8)*x761)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x764=(cj27*px);
IkReal x765=((321000.0)*cj30);
IkReal x766=((321000.0)*sj30);
CheckValue<IkReal> x768 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*x764*x766))+(((400000.0)*pz))+((pz*x765))+(((-1.0)*py*sj27*x766)))),IkReal(((40000.0)+(((-400000.0)*py*sj27))+(((-1.0)*x764*x765))+(((-400000.0)*x764))+(((32100.0)*cj30))+(((-1.0)*py*sj27*x765))+(((-1.0)*pz*x766)))),IKFAST_ATAN2_MAGTHRESH);
if(!x768.valid){
continue;
}
CheckValue<IkReal> x769=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj30)))),-1);
if(!x769.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x768.value)+(((1.5707963267949)*(x769.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x770=IKsin(j28);
IkReal x771=IKcos(j28);
IkReal x772=((0.321)*cj30);
IkReal x773=((0.321)*sj30);
IkReal x774=(py*sj27);
IkReal x775=(cj27*px);
IkReal x776=((1.0)*x774);
IkReal x777=(pz*x770);
IkReal x778=((1.0)*x771);
IkReal x779=((0.8)*x771);
evalcond[0]=(((x770*x772))+(((-1.0)*x771*x773))+pz+(((0.4)*x770)));
evalcond[1]=((0.1)+((x771*x772))+((x770*x773))+(((0.4)*x771))+(((-1.0)*x776))+(((-1.0)*x775)));
evalcond[2]=((0.4)+(((0.1)*x771))+(((-1.0)*x771*x776))+(((-1.0)*x775*x778))+x772+x777);
evalcond[3]=((((0.1)*x770))+(((-1.0)*x770*x775))+(((-1.0)*pz*x778))+x773+(((-1.0)*x770*x776)));
evalcond[4]=((-0.066959)+((x774*x779))+(((-0.08)*x771))+(((-1.0)*pp))+(((0.2)*x774))+(((0.2)*x775))+(((-0.8)*x777))+((x775*x779)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28, j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x780=IKPowWithIntegerCheck(sj29,-1);
if(!x780.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x780.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x780.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x780.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));
evalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j28eval[3];
IkReal x781=(py*sj27);
IkReal x782=(cj29*sj30);
IkReal x783=(cj27*px);
IkReal x784=((10.0)*cj30);
IkReal x785=((1000.0)*pz);
IkReal x786=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+((x781*x784))+(((12.4610591900312)*x781))+(((12.4610591900312)*x783))+((x783*x784))+(((-1.0)*cj30))+(((10.0)*pz*x782)));
j28eval[1]=IKsign(((-40.0)+((x781*x786))+(((400.0)*x783))+(((400.0)*x781))+((x783*x786))+(((321.0)*pz*x782))+(((-32.1)*cj30))));
j28eval[2]=((IKabs(((((-128.4)*x782))+(((100.0)*pz))+(((-103.041)*cj30*x782))+(((-1.0)*x781*x785))+(((-1.0)*x783*x785)))))+(IKabs(((160.0)+(((103.041)*(cj30*cj30)))+(((-1.0)*pz*x785))+(((256.8)*cj30))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
IkReal x787=cj29*cj29;
IkReal x788=cj30*cj30;
IkReal x789=(cj27*px);
IkReal x790=((321000.0)*cj30);
IkReal x791=(py*sj27);
IkReal x792=((321000.0)*cj29*sj30);
IkReal x793=((103041.0)*x788);
j28eval[0]=((1.5527799613746)+(((-1.0)*x787*x788))+x787+x788+(((2.49221183800623)*cj30)));
j28eval[1]=IKsign(((160000.0)+(((256800.0)*cj30))+(((-1.0)*x787*x793))+x793+(((103041.0)*x787))));
j28eval[2]=((IKabs(((-40000.0)+(((-32100.0)*cj30))+((x790*x791))+(((-1.0)*pz*x792))+(((400000.0)*x791))+(((400000.0)*x789))+((x789*x790)))))+(IKabs(((((32100.0)*cj29*sj30))+(((-1.0)*x791*x792))+(((-400000.0)*pz))+(((-1.0)*x789*x792))+(((-1.0)*pz*x790))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[2];
IkReal x794=(cj29*sj30);
IkReal x795=(py*sj27);
IkReal x796=(cj30*pz);
IkReal x797=(cj27*px);
j28eval[0]=((((10.0)*x796))+(((-10.0)*x794*x795))+(((-10.0)*x794*x797))+x794+(((12.4610591900312)*pz)));
j28eval[1]=IKsign(((((-321.0)*x794*x797))+(((-321.0)*x794*x795))+(((321.0)*x796))+(((400.0)*pz))+(((32.1)*x794))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x798=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x798);
rxp0_1=(px*r20);
rxp1_0=(r21*x798);
rxp1_1=(px*r21);
rxp2_0=(r22*x798);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x799=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x799);
rxp0_1=(px*r20);
rxp1_0=(r21*x799);
rxp1_1=(px*r21);
rxp2_0=(r22*x799);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x800=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x800) < -0.00001)
continue;
IkReal x801=IKabs(IKsqrt(x800));
IkReal x807 = x800;
if(IKabs(x807)==0){
continue;
}
IkReal x802=pow(x807,-0.5);
CheckValue<IkReal> x808=IKPowWithIntegerCheck(x801,-1);
if(!x808.valid){
continue;
}
IkReal x803=x808.value;
IkReal x804=((10.0)*px*x802);
IkReal x805=((10.0)*py*x802);
if((((1.0)+(((-1.0)*(x803*x803))))) < -0.00001)
continue;
IkReal x806=IKsqrt(((1.0)+(((-1.0)*(x803*x803)))));
CheckValue<IkReal> x809 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x809.valid){
continue;
}
if( (x803) < -1-IKFAST_SINCOS_THRESH || (x803) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst25=(((x804*x806))+((x803*x805)));
IkReal gconst26=((((-1.0)*x805*x806))+((x803*x804)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x810=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x810.valid){
continue;
}
if( (x810.value) < -1-IKFAST_SINCOS_THRESH || (x810.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x811 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x811.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x810.value))+j27+(x811.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);
if(!x813.valid){
continue;
}
IkReal x812=x813.value;
cj28array[0]=((((-0.4)*x812))+(((-0.321)*cj30*x812)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x814=IKsin(j28);
IkReal x815=IKcos(j28);
IkReal x816=(gconst25*py);
IkReal x817=(gconst26*px);
IkReal x818=((0.321)*cj30);
IkReal x819=((1.0)*x814);
IkReal x820=((0.8)*x815);
evalcond[0]=((((0.4)*x814))+((x814*x818)));
evalcond[1]=((((-1.0)*x816*x819))+(((-1.0)*x817*x819))+(((0.1)*x814)));
evalcond[2]=((0.1)+((x815*x818))+(((0.4)*x815))+(((-1.0)*x817))+(((-1.0)*x816)));
evalcond[3]=((-0.32)+((x817*x820))+((x816*x820))+(((-0.2568)*cj30))+(((-0.08)*x815)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x821=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x828 = x821;
if(IKabs(x828)==0){
continue;
}
IkReal x822=pow(x828,-0.5);
if((x821) < -0.00001)
continue;
IkReal x823=IKabs(IKsqrt(x821));
CheckValue<IkReal> x829=IKPowWithIntegerCheck(x823,-1);
if(!x829.valid){
continue;
}
IkReal x824=x829.value;
IkReal x825=((10.0)*px*x822);
IkReal x826=((10.0)*py*x822);
if((((1.0)+(((-1.0)*(x824*x824))))) < -0.00001)
continue;
IkReal x827=IKsqrt(((1.0)+(((-1.0)*(x824*x824)))));
if( (x824) < -1-IKFAST_SINCOS_THRESH || (x824) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x830 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x830.valid){
continue;
}
IkReal gconst28=(((x824*x826))+(((-1.0)*x825*x827)));
IkReal gconst29=(((x824*x825))+((x826*x827)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x831=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x831.valid){
continue;
}
if( (x831.value) < -1-IKFAST_SINCOS_THRESH || (x831.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x832 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x832.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x831.value))))+j27+(x832.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x834=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);
if(!x834.valid){
continue;
}
IkReal x833=x834.value;
cj28array[0]=((((-0.4)*x833))+(((-0.321)*cj30*x833)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x835=IKsin(j28);
IkReal x836=IKcos(j28);
IkReal x837=(gconst28*py);
IkReal x838=((0.321)*cj30);
IkReal x839=((0.8)*x836);
IkReal x840=((1.0)*gconst29*px);
evalcond[0]=((((0.4)*x835))+((x835*x838)));
evalcond[1]=((((-1.0)*x835*x840))+(((0.1)*x835))+(((-1.0)*x835*x837)));
evalcond[2]=((0.1)+(((0.4)*x836))+((x836*x838))+(((-1.0)*x840))+(((-1.0)*x837)));
evalcond[3]=((-0.32)+(((-0.08)*x836))+((x837*x839))+((gconst29*px*x839))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x842=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x842.valid){
continue;
}
IkReal x841=x842.value;
cj28array[0]=(((py*sj27*x841))+((cj27*px*x841))+(((-0.1)*x841)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x843=IKsin(j28);
IkReal x844=IKcos(j28);
IkReal x845=((0.321)*cj30);
IkReal x846=(cj27*px);
IkReal x847=((1.0)*x843);
IkReal x848=(py*sj27*x844);
evalcond[0]=((((0.4)*x843))+((x843*x845)));
evalcond[1]=((((-1.0)*py*sj27*x847))+(((-1.0)*x846*x847))+(((0.1)*x843)));
evalcond[2]=((0.4)+(((0.1)*x844))+(((-1.0)*x848))+x845+(((-1.0)*x844*x846)));
evalcond[3]=((-0.32)+(((-0.08)*x844))+(((0.8)*x848))+(((0.8)*x844*x846))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x850=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x850.valid){
continue;
}
IkReal x849=x850.value;
cj28array[0]=((((-0.4)*x849))+(((-0.321)*cj30*x849)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x851=IKsin(j28);
IkReal x852=IKcos(j28);
IkReal x853=(py*sj27);
IkReal x854=(cj27*px);
IkReal x855=((0.321)*cj30);
IkReal x856=((0.8)*x852);
IkReal x857=((1.0)*x851);
evalcond[0]=(((x851*x855))+(((0.4)*x851)));
evalcond[1]=((((-1.0)*x853*x857))+(((0.1)*x851))+(((-1.0)*x854*x857)));
evalcond[2]=((0.1)+(((-1.0)*x854))+(((-1.0)*x853))+((x852*x855))+(((0.4)*x852)));
evalcond[3]=((-0.32)+(((-0.2568)*cj30))+(((-0.08)*x852))+((x854*x856))+((x853*x856)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x858=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x858);
rxp0_1=(px*r20);
rxp1_0=(r21*x858);
rxp1_1=(px*r21);
rxp2_0=(r22*x858);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x859=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x859);
rxp0_1=(px*r20);
rxp1_0=(r21*x859);
rxp1_1=(px*r21);
rxp2_0=(r22*x859);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x860=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x860) < -0.00001)
continue;
IkReal x861=IKabs(IKsqrt(x860));
IkReal x867 = x860;
if(IKabs(x867)==0){
continue;
}
IkReal x862=pow(x867,-0.5);
CheckValue<IkReal> x868=IKPowWithIntegerCheck(x861,-1);
if(!x868.valid){
continue;
}
IkReal x863=x868.value;
IkReal x864=((10.0)*px*x862);
IkReal x865=((10.0)*py*x862);
if((((1.0)+(((-1.0)*(x863*x863))))) < -0.00001)
continue;
IkReal x866=IKsqrt(((1.0)+(((-1.0)*(x863*x863)))));
if( (x863) < -1-IKFAST_SINCOS_THRESH || (x863) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x869.valid){
continue;
}
IkReal gconst31=(((x863*x865))+((x864*x866)));
IkReal gconst32=((((-1.0)*x865*x866))+((x863*x864)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x870=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x870.valid){
continue;
}
if( (x870.value) < -1-IKFAST_SINCOS_THRESH || (x870.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x871 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x871.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x870.value))+j27+(x871.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x873=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);
if(!x873.valid){
continue;
}
IkReal x872=x873.value;
cj28array[0]=((((-0.4)*x872))+(((-0.321)*cj30*x872)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x874=IKsin(j28);
IkReal x875=IKcos(j28);
IkReal x876=(gconst31*py);
IkReal x877=(gconst32*px);
IkReal x878=((0.321)*cj30);
IkReal x879=((0.8)*x875);
evalcond[0]=(((x874*x878))+(((0.4)*x874)));
evalcond[1]=(((x874*x877))+((x874*x876))+(((-0.1)*x874)));
evalcond[2]=((0.1)+(((-1.0)*x876))+(((-1.0)*x877))+(((0.4)*x875))+((x875*x878)));
evalcond[3]=((-0.32)+((x876*x879))+(((-0.2568)*cj30))+(((-0.08)*x875))+((x877*x879)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x880=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x887 = x880;
if(IKabs(x887)==0){
continue;
}
IkReal x881=pow(x887,-0.5);
if((x880) < -0.00001)
continue;
IkReal x882=IKabs(IKsqrt(x880));
CheckValue<IkReal> x888=IKPowWithIntegerCheck(x882,-1);
if(!x888.valid){
continue;
}
IkReal x883=x888.value;
IkReal x884=((10.0)*px*x881);
IkReal x885=((10.0)*py*x881);
if((((1.0)+(((-1.0)*(x883*x883))))) < -0.00001)
continue;
IkReal x886=IKsqrt(((1.0)+(((-1.0)*(x883*x883)))));
if( (x883) < -1-IKFAST_SINCOS_THRESH || (x883) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x889 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x889.valid){
continue;
}
IkReal gconst34=(((x883*x885))+(((-1.0)*x884*x886)));
IkReal gconst35=(((x883*x884))+((x885*x886)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x890=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x890.valid){
continue;
}
if( (x890.value) < -1-IKFAST_SINCOS_THRESH || (x890.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x891 = IKatan2WithCheck(IkReal(((-10.0)*px)),IkReal(((-10.0)*py)),IKFAST_ATAN2_MAGTHRESH);
if(!x891.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x890.value))))+j27+(x891.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x893=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);
if(!x893.valid){
continue;
}
IkReal x892=x893.value;
cj28array[0]=((((-0.4)*x892))+(((-0.321)*cj30*x892)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x894=IKsin(j28);
IkReal x895=IKcos(j28);
IkReal x896=(gconst34*py);
IkReal x897=(gconst35*px);
IkReal x898=((0.321)*cj30);
IkReal x899=((0.8)*x895);
evalcond[0]=(((x894*x898))+(((0.4)*x894)));
evalcond[1]=((((-0.1)*x894))+((x894*x897))+((x894*x896)));
evalcond[2]=((0.1)+((x895*x898))+(((0.4)*x895))+(((-1.0)*x897))+(((-1.0)*x896)));
evalcond[3]=((-0.32)+((x896*x899))+((x897*x899))+(((-0.2568)*cj30))+(((-0.08)*x895)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x901=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x901.valid){
continue;
}
IkReal x900=x901.value;
cj28array[0]=(((cj27*px*x900))+((py*sj27*x900))+(((-0.1)*x900)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x902=IKsin(j28);
IkReal x903=IKcos(j28);
IkReal x904=((0.321)*cj30);
IkReal x905=(py*sj27*x903);
IkReal x906=(cj27*px*x903);
evalcond[0]=(((x902*x904))+(((0.4)*x902)));
evalcond[1]=(((cj27*px*x902))+((py*sj27*x902))+(((-0.1)*x902)));
evalcond[2]=((0.4)+(((-1.0)*x906))+(((-1.0)*x905))+x904+(((0.1)*x903)));
evalcond[3]=((-0.32)+(((-0.08)*x903))+(((-0.2568)*cj30))+(((0.8)*x905))+(((0.8)*x906)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x908=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x908.valid){
continue;
}
IkReal x907=x908.value;
cj28array[0]=((((-0.321)*cj30*x907))+(((-0.4)*x907)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x909=IKsin(j28);
IkReal x910=IKcos(j28);
IkReal x911=(py*sj27);
IkReal x912=(cj27*px);
IkReal x913=((0.321)*cj30);
IkReal x914=((0.8)*x910);
evalcond[0]=(((x909*x913))+(((0.4)*x909)));
evalcond[1]=(((x909*x912))+((x909*x911))+(((-0.1)*x909)));
evalcond[2]=((0.1)+((x910*x913))+(((0.4)*x910))+(((-1.0)*x912))+(((-1.0)*x911)));
evalcond[3]=((-0.32)+(((-0.08)*x910))+((x911*x914))+(((-0.2568)*cj30))+((x912*x914)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x915=IKcos(j28);
IkReal x916=px*px;
CheckValue<IkReal> x925=IKPowWithIntegerCheck(py,-1);
if(!x925.valid){
continue;
}
IkReal x917=x925.value;
IkReal x918=IKsin(j28);
IkReal x919=(py*sj27);
IkReal x920=(x916*x917);
IkReal x921=((1.0)*x915);
IkReal x922=(sj29*x918);
IkReal x923=(cj29*x918);
IkReal x924=((0.8)*sj27*x915);
evalcond[0]=((0.721)*x918);
evalcond[1]=((0.721)+(((-1.0)*x919*x921))+(((0.1)*x915))+(((-1.0)*cj27*px*x921)));
evalcond[2]=((-0.5768)+((x920*x924))+(((-0.08)*x915))+(((0.8)*x915*x919)));
evalcond[3]=(((x919*x923))+(((-0.1)*x923))+((sj27*x920*x923)));
evalcond[4]=((((0.1)*x922))+(((-1.0)*sj27*x920*x922))+(((-1.0)*x919*x922)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x926=IKcos(j28);
IkReal x927=px*px;
CheckValue<IkReal> x936=IKPowWithIntegerCheck(py,-1);
if(!x936.valid){
continue;
}
IkReal x928=x936.value;
IkReal x929=IKsin(j28);
IkReal x930=(py*sj27);
IkReal x931=(x927*x928);
IkReal x932=((1.0)*x926);
IkReal x933=(sj29*x929);
IkReal x934=(cj29*x929);
IkReal x935=((0.8)*sj27*x926);
evalcond[0]=((0.079)*x929);
evalcond[1]=((0.079)+(((0.1)*x926))+(((-1.0)*x930*x932))+(((-1.0)*cj27*px*x932)));
evalcond[2]=((-0.0632)+(((-0.08)*x926))+((x931*x935))+(((0.8)*x926*x930)));
evalcond[3]=((((-0.1)*x934))+((sj27*x931*x934))+((x930*x934)));
evalcond[4]=((((0.1)*x933))+(((-1.0)*sj27*x931*x933))+(((-1.0)*x930*x933)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x937=cj27*cj27;
IkReal x938=py*py;
IkReal x939=(cj27*px);
IkReal x940=(cj29*sj30);
IkReal x941=(py*sj27);
IkReal x942=((1000.0)*pz);
IkReal x943=((1000.0)*x937);
CheckValue<IkReal> x944 = IKatan2WithCheck(IkReal(((-150.0)+(((-200.0)*x941))+(((-200.0)*x939))+(((-1.0)*x938*x943))+(((1000.0)*x938))+((x943*(px*px)))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))+(((2000.0)*x939*x941)))),IkReal(((((-100.0)*pz))+(((-103.041)*cj30*x940))+((x939*x942))+(((-128.4)*x940))+((x941*x942)))),IKFAST_ATAN2_MAGTHRESH);
if(!x944.valid){
continue;
}
CheckValue<IkReal> x945=IKPowWithIntegerCheck(IKsign(((((321.0)*cj30*pz))+(((-321.0)*x940*x941))+(((400.0)*pz))+(((-321.0)*x939*x940))+(((32.1)*x940)))),-1);
if(!x945.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x944.value)+(((1.5707963267949)*(x945.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x946=IKsin(j28);
IkReal x947=IKcos(j28);
IkReal x948=((0.321)*cj30);
IkReal x949=(py*sj27);
IkReal x950=((0.321)*sj30);
IkReal x951=((1.0)*sj29);
IkReal x952=(px*sj27);
IkReal x953=(cj27*px);
IkReal x954=(cj27*py);
IkReal x955=((1.0)*x949);
IkReal x956=(pz*x946);
IkReal x957=(cj29*x946);
IkReal x958=(pz*x947);
IkReal x959=((0.8)*x947);
IkReal x960=(sj29*x946);
evalcond[0]=(((x946*x948))+((cj29*x947*x950))+pz+(((0.4)*x946)));
evalcond[1]=((0.1)+((x947*x948))+(((-1.0)*x953))+(((-1.0)*x950*x957))+(((0.4)*x947))+(((-1.0)*x955)));
evalcond[2]=((0.4)+(((-1.0)*x947*x953))+(((-1.0)*x947*x955))+x956+x948+(((0.1)*x947)));
evalcond[3]=((-0.066959)+(((-0.08)*x947))+(((-0.8)*x956))+((x949*x959))+(((0.2)*x949))+(((-1.0)*pp))+(((0.2)*x953))+((x953*x959)));
evalcond[4]=((((0.1)*x960))+(((-1.0)*cj29*x954))+((cj29*x952))+(((-1.0)*x946*x949*x951))+(((-1.0)*x951*x958))+(((-1.0)*x946*x951*x953)));
evalcond[5]=(((sj29*x952))+(((-0.1)*x957))+((x949*x957))+((cj29*x958))+(((-1.0)*x951*x954))+((x953*x957))+x950);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x961=cj29*cj29;
IkReal x962=cj30*cj30;
IkReal x963=(cj27*px);
IkReal x964=((321000.0)*cj30);
IkReal x965=(py*sj27);
IkReal x966=((321000.0)*cj29*sj30);
IkReal x967=((103041.0)*x961);
CheckValue<IkReal> x968 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x964))+(((-1.0)*x965*x966))+(((-1.0)*x963*x966))+(((32100.0)*cj29*sj30))+(((-400000.0)*pz)))),IkReal(((-40000.0)+(((-1.0)*pz*x966))+(((-32100.0)*cj30))+((x964*x965))+((x963*x964))+(((400000.0)*x963))+(((400000.0)*x965)))),IKFAST_ATAN2_MAGTHRESH);
if(!x968.valid){
continue;
}
CheckValue<IkReal> x969=IKPowWithIntegerCheck(IKsign(((160000.0)+(((-1.0)*x962*x967))+(((256800.0)*cj30))+x967+(((103041.0)*x962)))),-1);
if(!x969.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x968.value)+(((1.5707963267949)*(x969.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x970=IKsin(j28);
IkReal x971=IKcos(j28);
IkReal x972=((0.321)*cj30);
IkReal x973=(py*sj27);
IkReal x974=((0.321)*sj30);
IkReal x975=((1.0)*sj29);
IkReal x976=(px*sj27);
IkReal x977=(cj27*px);
IkReal x978=(cj27*py);
IkReal x979=((1.0)*x973);
IkReal x980=(pz*x970);
IkReal x981=(cj29*x970);
IkReal x982=(pz*x971);
IkReal x983=((0.8)*x971);
IkReal x984=(sj29*x970);
evalcond[0]=(pz+((x970*x972))+((cj29*x971*x974))+(((0.4)*x970)));
evalcond[1]=((0.1)+(((-1.0)*x977))+(((-1.0)*x974*x981))+((x971*x972))+(((0.4)*x971))+(((-1.0)*x979)));
evalcond[2]=((0.4)+(((0.1)*x971))+(((-1.0)*x971*x979))+(((-1.0)*x971*x977))+x980+x972);
evalcond[3]=((-0.066959)+(((-0.8)*x980))+((x977*x983))+((x973*x983))+(((-1.0)*pp))+(((0.2)*x973))+(((0.2)*x977))+(((-0.08)*x971)));
evalcond[4]=((((-1.0)*cj29*x978))+(((0.1)*x984))+(((-1.0)*x970*x975*x977))+(((-1.0)*x970*x973*x975))+((cj29*x976))+(((-1.0)*x975*x982)));
evalcond[5]=((((-0.1)*x981))+((x977*x981))+((sj29*x976))+((x973*x981))+((cj29*x982))+x974+(((-1.0)*x975*x978)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x985=(py*sj27);
IkReal x986=(cj29*sj30);
IkReal x987=((321.0)*cj30);
IkReal x988=(cj27*px);
IkReal x989=((1000.0)*pz);
CheckValue<IkReal> x990 = IKatan2WithCheck(IkReal(((((-103.041)*cj30*x986))+(((100.0)*pz))+(((-1.0)*x988*x989))+(((-128.4)*x986))+(((-1.0)*x985*x989)))),IkReal(((160.0)+(((-1.0)*pz*x989))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))),IKFAST_ATAN2_MAGTHRESH);
if(!x990.valid){
continue;
}
CheckValue<IkReal> x991=IKPowWithIntegerCheck(IKsign(((-40.0)+(((321.0)*pz*x986))+(((400.0)*x988))+(((400.0)*x985))+((x987*x988))+((x985*x987))+(((-32.1)*cj30)))),-1);
if(!x991.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x990.value)+(((1.5707963267949)*(x991.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x992=IKsin(j28);
IkReal x993=IKcos(j28);
IkReal x994=((0.321)*cj30);
IkReal x995=(py*sj27);
IkReal x996=((0.321)*sj30);
IkReal x997=((1.0)*sj29);
IkReal x998=(px*sj27);
IkReal x999=(cj27*px);
IkReal x1000=(cj27*py);
IkReal x1001=((1.0)*x995);
IkReal x1002=(pz*x992);
IkReal x1003=(cj29*x992);
IkReal x1004=(pz*x993);
IkReal x1005=((0.8)*x993);
IkReal x1006=(sj29*x992);
evalcond[0]=((((0.4)*x992))+((cj29*x993*x996))+((x992*x994))+pz);
evalcond[1]=((0.1)+((x993*x994))+(((-1.0)*x999))+(((0.4)*x993))+(((-1.0)*x1001))+(((-1.0)*x1003*x996)));
evalcond[2]=((0.4)+(((-1.0)*x993*x999))+x1002+(((0.1)*x993))+(((-1.0)*x1001*x993))+x994);
evalcond[3]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x993))+(((-0.8)*x1002))+((x1005*x999))+((x1005*x995))+(((0.2)*x995))+(((0.2)*x999)));
evalcond[4]=((((0.1)*x1006))+(((-1.0)*cj29*x1000))+((cj29*x998))+(((-1.0)*x992*x995*x997))+(((-1.0)*x1004*x997))+(((-1.0)*x992*x997*x999)));
evalcond[5]=(((cj29*x1004))+((x1003*x999))+((x1003*x995))+((sj29*x998))+(((-1.0)*x1000*x997))+x996+(((-0.1)*x1003)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1007=cj27*cj27;
IkReal x1008=px*px;
IkReal x1009=py*py;
IkReal x1010=((1.0)*pz);
IkReal x1011=(cj27*px);
IkReal x1012=((5.0)*pp);
IkReal x1013=(cj29*py);
IkReal x1014=((4.0)*cj27);
IkReal x1015=(pz*sj29);
IkReal x1016=(cj29*sj27);
IkReal x1017=(py*sj27*sj29);
IkReal x1019=(sj29*x1007);
IkReal x1020=((4.0)*x1009);
CheckValue<IkReal> x1021=IKPowWithIntegerCheck(IKsign(((((-1.0)*sj29*x1020))+((x1019*x1020))+(((-8.0)*x1011*x1017))+(((-0.04)*sj29))+(((-4.0)*x1008*x1019))+(((0.8)*x1017))+(((-4.0)*pz*x1015))+(((0.8)*sj29*x1011)))),-1);
if(!x1021.valid){
continue;
}
CheckValue<IkReal> x1022 = IKatan2WithCheck(IkReal(((((-0.4)*cj27*x1013))+(((-1.0)*x1010*x1017))+(((-4.0)*px*x1013))+(((-1.0)*x1008*x1014*x1016))+((x1009*x1014*x1016))+((x1012*x1015))+(((-1.0)*sj29*x1010*x1011))+(((8.0)*px*x1007*x1013))+(((0.334795)*x1015))+(((0.4)*px*x1016)))),IkReal(((((-1.0)*x1012*x1017))+(((0.5)*pp*sj29))+(((-1.0)*x1009*x1019))+((pz*x1013*x1014))+(((0.0334795)*sj29))+(((2.0)*x1011*x1017))+(((-4.0)*px*pz*x1016))+((sj29*x1009))+(((-0.434795)*sj29*x1011))+(((-0.434795)*x1017))+(((-1.0)*sj29*x1011*x1012))+((x1008*x1019)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1022.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1021.value)))+(x1022.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[2];
IkReal x1023=IKcos(j28);
IkReal x1024=IKsin(j28);
IkReal x1025=(py*sj27);
IkReal x1026=((1.0)*cj27);
IkReal x1027=(cj27*px);
IkReal x1028=((0.8)*x1023);
IkReal x1029=(sj29*x1024);
evalcond[0]=((-0.066959)+(((-0.8)*pz*x1024))+(((-1.0)*pp))+(((-0.08)*x1023))+((x1025*x1028))+(((0.2)*x1025))+(((0.2)*x1027))+((x1027*x1028)));
evalcond[1]=(((cj29*px*sj27))+(((-1.0)*px*x1026*x1029))+(((-1.0)*cj29*py*x1026))+(((-1.0)*pz*sj29*x1023))+(((0.1)*x1029))+(((-1.0)*x1025*x1029)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=cj28;
j30eval[1]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=sj29;
j30eval[1]=sj28;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1030=((3.11526479750779)*cj28);
IkReal x1031=(py*sj27);
IkReal x1032=((3.11526479750779)*sj28);
IkReal x1033=(cj27*px);
if( IKabs(((((-1.0)*x1032*x1033))+(((-1.0)*pz*x1030))+(((-1.0)*x1031*x1032))+(((0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1030*x1033))+((x1030*x1031))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1032)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1032*x1033))+(((-1.0)*pz*x1030))+(((-1.0)*x1031*x1032))+(((0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+((x1030*x1033))+((x1030*x1031))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1032))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-1.0)*x1032*x1033))+(((-1.0)*pz*x1030))+(((-1.0)*x1031*x1032))+(((0.311526479750779)*sj28))), ((-1.24610591900312)+((x1030*x1033))+((x1030*x1031))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1032))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1034=IKcos(j30);
IkReal x1035=IKsin(j30);
IkReal x1036=(py*sj27);
IkReal x1037=(cj27*px);
IkReal x1038=((0.321)*x1034);
IkReal x1039=((0.321)*x1035);
evalcond[0]=((((0.4)*sj28))+((cj28*x1039))+pz+((sj28*x1038)));
evalcond[1]=((0.253041)+(((0.2568)*x1034))+(((-1.0)*pp))+(((0.2)*x1036))+(((0.2)*x1037)));
evalcond[2]=(x1039+((cj28*pz))+((sj28*x1037))+((sj28*x1036))+(((-0.1)*sj28)));
CheckValue<IkReal> x1040=IKPowWithIntegerCheck(py,-1);
if(!x1040.valid){
continue;
}
evalcond[3]=((0.31630125)+x1038+(((-1.25)*pp))+(((0.25)*x1036))+(((0.25)*sj27*(px*px)*(x1040.value))));
evalcond[4]=((0.1)+((cj28*x1038))+(((-1.0)*x1037))+(((-1.0)*x1036))+(((0.4)*cj28))+(((-1.0)*sj28*x1039)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1041=((3.11526479750779)*cj28);
IkReal x1042=(py*sj27);
IkReal x1043=((3.11526479750779)*sj28);
IkReal x1044=(cj27*px);
if( IKabs((((x1042*x1043))+((x1043*x1044))+((pz*x1041))+(((-0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+((x1041*x1042))+((x1041*x1044))+(((-1.0)*pz*x1043)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1042*x1043))+((x1043*x1044))+((pz*x1041))+(((-0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+((x1041*x1042))+((x1041*x1044))+(((-1.0)*pz*x1043))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((((x1042*x1043))+((x1043*x1044))+((pz*x1041))+(((-0.311526479750779)*sj28))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+((x1041*x1042))+((x1041*x1044))+(((-1.0)*pz*x1043))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1045=IKcos(j30);
IkReal x1046=IKsin(j30);
IkReal x1047=(cj27*px);
IkReal x1048=((1.0)*sj28);
IkReal x1049=((0.25)*sj27);
IkReal x1050=(py*sj27);
IkReal x1051=((0.321)*x1045);
IkReal x1052=((0.321)*x1046);
evalcond[0]=((((0.4)*sj28))+pz+(((-1.0)*cj28*x1052))+((sj28*x1051)));
evalcond[1]=((0.253041)+(((0.2)*x1047))+(((0.2)*x1050))+(((-1.0)*pp))+(((0.2568)*x1045)));
CheckValue<IkReal> x1053=IKPowWithIntegerCheck(py,-1);
if(!x1053.valid){
continue;
}
evalcond[2]=((0.31630125)+x1051+(((-1.25)*pp))+((x1049*(px*px)*(x1053.value)))+((py*x1049)));
evalcond[3]=(x1052+(((0.1)*sj28))+(((-1.0)*x1048*x1050))+(((-1.0)*cj28*pz))+(((-1.0)*x1047*x1048)));
evalcond[4]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1050))+(((-1.0)*x1047))+((cj28*x1051))+((sj28*x1052)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1054=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1054)));
evalcond[2]=((0.353041)+(((0.321)*x1054))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1055=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1055)));
evalcond[2]=((0.353041)+(((0.321)*x1055))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1056=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1056)));
evalcond[1]=((0.353041)+(((0.321)*x1056))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1057=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1057)));
evalcond[1]=((0.353041)+(((0.321)*x1057))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1058=IKPowWithIntegerCheck(sj29,-1);
if(!x1058.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1058.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1058.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1058.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1059=IKcos(j30);
IkReal x1060=IKsin(j30);
IkReal x1061=(px*sj27);
IkReal x1062=((1.0)*cj27*py);
IkReal x1063=((0.321)*x1060);
evalcond[0]=(pz+((cj29*x1063)));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1059)));
evalcond[2]=((0.353041)+(((0.321)*x1059))+(((-1.0)*pp)));
evalcond[3]=(x1061+(((-1.0)*x1062))+((sj29*x1063)));
evalcond[4]=(x1063+(((-1.0)*sj29*x1062))+((cj29*pz))+((sj29*x1061)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1064=IKPowWithIntegerCheck(cj29,-1);
if(!x1064.valid){
continue;
}
if( IKabs(((-3.11526479750779)*pz*(x1064.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1064.value)))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz*(x1064.value)), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1065=IKcos(j30);
IkReal x1066=IKsin(j30);
IkReal x1067=(px*sj27);
IkReal x1068=((1.0)*cj27*py);
IkReal x1069=((0.321)*x1066);
evalcond[0]=(pz+((cj29*x1069)));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1065)));
evalcond[2]=((0.353041)+(((0.321)*x1065))+(((-1.0)*pp)));
evalcond[3]=(x1067+(((-1.0)*x1068))+((sj29*x1069)));
evalcond[4]=(x1069+(((-1.0)*sj29*x1068))+((cj29*pz))+((sj29*x1067)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1070=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.257388)+(((0.2568)*x1070))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1070))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1071=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.257388)+(((0.2568)*x1071))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1071))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1072=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1072))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1072))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1073=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1073))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1073))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1074=IKPowWithIntegerCheck(sj29,-1);
if(!x1074.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1074.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1074.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1074.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1075=IKcos(j30);
IkReal x1076=IKsin(j30);
IkReal x1077=(px*sj27);
IkReal x1078=((1.0)*cj27*py);
IkReal x1079=((0.321)*x1076);
evalcond[0]=(pz+(((-1.0)*cj29*x1079)));
evalcond[1]=((0.257388)+(((0.2568)*x1075))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1075))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1077+((sj29*x1079))+(((-1.0)*x1078)));
evalcond[4]=((((-1.0)*sj29*x1078))+x1079+(((-1.0)*cj29*pz))+((sj29*x1077)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1080=IKPowWithIntegerCheck(cj29,-1);
if(!x1080.valid){
continue;
}
if( IKabs(((3.11526479750779)*pz*(x1080.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1080.value)))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz*(x1080.value)), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1081=IKcos(j30);
IkReal x1082=IKsin(j30);
IkReal x1083=(px*sj27);
IkReal x1084=((1.0)*cj27*py);
IkReal x1085=((0.321)*x1082);
evalcond[0]=(pz+(((-1.0)*cj29*x1085)));
evalcond[1]=((0.257388)+(((0.2568)*x1081))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1081))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1083+((sj29*x1085))+(((-1.0)*x1084)));
evalcond[4]=(x1085+((sj29*x1083))+(((-1.0)*cj29*pz))+(((-1.0)*sj29*x1084)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1086=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1086))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1086)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1087=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1087))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1087)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1088=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1088))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1088)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1089=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1089))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1089)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1090=IKPowWithIntegerCheck(cj29,-1);
if(!x1090.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1090.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1090.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1090.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1091=IKcos(j30);
IkReal x1092=IKsin(j30);
IkReal x1093=((1.0)*py);
IkReal x1094=(cj27*px);
IkReal x1095=(px*sj27);
IkReal x1096=((0.321)*x1092);
evalcond[0]=((0.4)+pz+(((0.321)*x1091)));
evalcond[1]=((0.32)+(((0.2568)*x1091))+(((0.8)*pz)));
evalcond[2]=(x1095+((sj29*x1096))+(((-1.0)*cj27*x1093)));
evalcond[3]=((0.1)+(((-1.0)*x1094))+(((-1.0)*cj29*x1096))+(((-1.0)*sj27*x1093)));
evalcond[4]=(((cj29*py*sj27))+x1096+((cj29*x1094))+((sj29*x1095))+(((-1.0)*cj27*sj29*x1093))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1097=IKPowWithIntegerCheck(sj29,-1);
if(!x1097.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1097.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1097.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1097.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1098=IKcos(j30);
IkReal x1099=IKsin(j30);
IkReal x1100=((1.0)*py);
IkReal x1101=(cj27*px);
IkReal x1102=(px*sj27);
IkReal x1103=((0.321)*x1099);
evalcond[0]=((0.4)+pz+(((0.321)*x1098)));
evalcond[1]=((0.32)+(((0.2568)*x1098))+(((0.8)*pz)));
evalcond[2]=(x1102+(((-1.0)*cj27*x1100))+((sj29*x1103)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1100))+(((-1.0)*x1101))+(((-1.0)*cj29*x1103)));
evalcond[4]=(((cj29*x1101))+((cj29*py*sj27))+x1103+(((-1.0)*cj27*sj29*x1100))+((sj29*x1102))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1104=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1104))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1104)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1105=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1105))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1105)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1106=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1106))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1106)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1107=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1107))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1107)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1108=IKPowWithIntegerCheck(cj29,-1);
if(!x1108.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1108.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1108.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1108.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1109=IKcos(j30);
IkReal x1110=IKsin(j30);
IkReal x1111=((1.0)*py);
IkReal x1112=(px*sj27);
IkReal x1113=((1.0)*cj27*px);
IkReal x1114=((0.321)*x1110);
evalcond[0]=((-0.4)+(((-0.321)*x1109))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1109)));
evalcond[2]=(x1112+(((-1.0)*cj27*x1111))+((sj29*x1114)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1111))+(((-1.0)*x1113))+((cj29*x1114)));
evalcond[4]=(x1114+(((-1.0)*cj27*sj29*x1111))+((sj29*x1112))+(((-1.0)*cj29*x1113))+(((0.1)*cj29))+(((-1.0)*cj29*sj27*x1111)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(sj29,-1);
if(!x1115.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1115.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1115.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1115.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1116=IKcos(j30);
IkReal x1117=IKsin(j30);
IkReal x1118=((1.0)*py);
IkReal x1119=(px*sj27);
IkReal x1120=((1.0)*cj27*px);
IkReal x1121=((0.321)*x1117);
evalcond[0]=((-0.4)+(((-0.321)*x1116))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1116)));
evalcond[2]=(x1119+((sj29*x1121))+(((-1.0)*cj27*x1118)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1118))+(((-1.0)*x1120))+((cj29*x1121)));
evalcond[4]=(x1121+(((-1.0)*cj27*sj29*x1118))+((sj29*x1119))+(((0.1)*cj29))+(((-1.0)*cj29*sj27*x1118))+(((-1.0)*cj29*x1120)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1122=IKcos(j30);
IkReal x1123=((1.0)*py);
IkReal x1124=(cj27*px);
IkReal x1125=((0.321)*x1122);
evalcond[0]=((((0.4)*sj28))+((sj28*x1125))+pz);
evalcond[1]=((((-1.0)*cj27*x1123))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1124))+(((0.2568)*x1122))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*sj27*x1123))+(((-1.0)*x1124))+((cj28*x1125)));
evalcond[4]=((0.4)+x1125+(((-1.0)*cj28*sj27*x1123))+(((-1.0)*cj28*x1124))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1126=IKcos(j30);
IkReal x1127=((1.0)*py);
IkReal x1128=(cj27*px);
IkReal x1129=((0.321)*x1126);
evalcond[0]=((((0.4)*sj28))+((sj28*x1129))+pz);
evalcond[1]=((((-0.321)*(IKsin(j30))))+(((-1.0)*cj27*x1127))+((px*sj27)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1128))+(((0.2568)*x1126))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*sj27*x1127))+(((-1.0)*x1128))+((cj28*x1129)));
evalcond[4]=((0.4)+x1129+(((-1.0)*cj28*sj27*x1127))+(((-1.0)*cj28*x1128))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1135=IKPowWithIntegerCheck(sj29,-1);
if(!x1135.valid){
continue;
}
IkReal x1130=x1135.value;
IkReal x1131=((0.00311526479750779)*x1130);
IkReal x1132=(cj28*cj29);
IkReal x1133=((1000.0)*cj27*py);
IkReal x1134=((1000.0)*px*sj27);
CheckValue<IkReal> x1136=IKPowWithIntegerCheck(sj28,-1);
if(!x1136.valid){
continue;
}
if( IKabs((x1131*((x1133+(((-1.0)*x1134)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1131*(x1136.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1132*x1133))+((x1132*x1134)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1131*((x1133+(((-1.0)*x1134))))))+IKsqr((x1131*(x1136.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1132*x1133))+((x1132*x1134))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((x1131*((x1133+(((-1.0)*x1134))))), (x1131*(x1136.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1132*x1133))+((x1132*x1134))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1137=IKsin(j30);
IkReal x1138=IKcos(j30);
IkReal x1139=((1.0)*py);
IkReal x1140=(cj29*sj28);
IkReal x1141=(cj27*px);
IkReal x1142=(cj28*cj29);
IkReal x1143=(py*sj27);
IkReal x1144=(px*sj27);
IkReal x1145=((0.321)*x1137);
IkReal x1146=((0.321)*x1138);
evalcond[0]=(x1144+((sj29*x1145))+(((-1.0)*cj27*x1139)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1138))+(((0.2)*x1143))+(((0.2)*x1141)));
evalcond[2]=((((0.4)*sj28))+((x1142*x1145))+((sj28*x1146))+pz);
evalcond[3]=((0.4)+x1146+(((-1.0)*cj28*x1141))+(((0.1)*cj28))+((pz*sj28))+(((-1.0)*cj28*sj27*x1139)));
evalcond[4]=((0.1)+(((-1.0)*x1140*x1145))+(((0.4)*cj28))+(((-1.0)*x1141))+((cj28*x1146))+(((-1.0)*sj27*x1139)));
evalcond[5]=(((x1140*x1143))+((x1140*x1141))+x1145+((pz*x1142))+((sj29*x1144))+(((-0.1)*x1140))+(((-1.0)*cj27*sj29*x1139)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1147=((250.0)*sj28);
IkReal x1148=(py*sj27);
IkReal x1149=(cj27*px);
CheckValue<IkReal> x1150=IKPowWithIntegerCheck(cj28,-1);
if(!x1150.valid){
continue;
}
CheckValue<IkReal> x1151=IKPowWithIntegerCheck(cj29,-1);
if(!x1151.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1150.value)*(x1151.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1147*x1149))+((x1147*x1148)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1148))+(((-0.778816199376947)*x1149)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1150.value)*(x1151.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1147*x1149))+((x1147*x1148))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1148))+(((-0.778816199376947)*x1149))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1150.value)*(x1151.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1147*x1149))+((x1147*x1148))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1148))+(((-0.778816199376947)*x1149))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1152=IKsin(j30);
IkReal x1153=IKcos(j30);
IkReal x1154=((1.0)*py);
IkReal x1155=(cj29*sj28);
IkReal x1156=(cj27*px);
IkReal x1157=(cj28*cj29);
IkReal x1158=(py*sj27);
IkReal x1159=(px*sj27);
IkReal x1160=((0.321)*x1152);
IkReal x1161=((0.321)*x1153);
evalcond[0]=(x1159+(((-1.0)*cj27*x1154))+((sj29*x1160)));
evalcond[1]=((0.253041)+(((0.2)*x1156))+(((0.2)*x1158))+(((0.2568)*x1153))+(((-1.0)*pp)));
evalcond[2]=((((0.4)*sj28))+((x1157*x1160))+pz+((sj28*x1161)));
evalcond[3]=((0.4)+x1161+(((-1.0)*cj28*sj27*x1154))+(((-1.0)*cj28*x1156))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj27*x1154))+(((0.4)*cj28))+(((-1.0)*x1156))+(((-1.0)*x1155*x1160))+((cj28*x1161)));
evalcond[5]=(((pz*x1157))+x1160+(((-1.0)*cj27*sj29*x1154))+((sj29*x1159))+(((-0.1)*x1155))+((x1155*x1156))+((x1155*x1158)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1162=IKPowWithIntegerCheck(sj29,-1);
if(!x1162.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1162.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1162.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1162.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1163=IKsin(j30);
IkReal x1164=IKcos(j30);
IkReal x1165=((1.0)*py);
IkReal x1166=(cj29*sj28);
IkReal x1167=(cj27*px);
IkReal x1168=(cj28*cj29);
IkReal x1169=(py*sj27);
IkReal x1170=(px*sj27);
IkReal x1171=((0.321)*x1163);
IkReal x1172=((0.321)*x1164);
evalcond[0]=(x1170+(((-1.0)*cj27*x1165))+((sj29*x1171)));
evalcond[1]=((0.253041)+(((0.2568)*x1164))+(((-1.0)*pp))+(((0.2)*x1167))+(((0.2)*x1169)));
evalcond[2]=((((0.4)*sj28))+((x1168*x1171))+pz+((sj28*x1172)));
evalcond[3]=((0.4)+x1172+(((-1.0)*cj28*x1167))+(((0.1)*cj28))+(((-1.0)*cj28*sj27*x1165))+((pz*sj28)));
evalcond[4]=((0.1)+((cj28*x1172))+(((0.4)*cj28))+(((-1.0)*sj27*x1165))+(((-1.0)*x1166*x1171))+(((-1.0)*x1167)));
evalcond[5]=(x1171+((x1166*x1169))+((x1166*x1167))+((pz*x1168))+(((-0.1)*x1166))+(((-1.0)*cj27*sj29*x1165))+((sj29*x1170)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x212=(sj27*sj29);
IkReal x213=(cj27*sj29);
IkReal x214=(cj28*sj29);
IkReal x215=(cj28*cj30);
IkReal x216=((1.0)*sj30);
IkReal x217=((1.0)*cj29);
IkReal x218=(cj29*x216);
IkReal x219=((1.0)*cj30*sj28);
IkReal x220=(((sj28*sj30))+(((-1.0)*x215*x217)));
IkReal x221=((((-1.0)*sj27*x217))+((sj28*x213)));
IkReal x222=(((sj28*x212))+((cj27*cj29)));
IkReal x223=(x215+(((-1.0)*sj28*x218)));
IkReal x224=(cj27*x223);
IkReal x225=((((-1.0)*cj28*x216))+(((-1.0)*cj30*sj28*x217)));
IkReal x226=((((-1.0)*cj28*x218))+(((-1.0)*x219)));
IkReal x227=(cj27*x225);
IkReal x228=(((sj30*x213))+((sj27*x223)));
IkReal x229=(x224+(((-1.0)*sj30*x212)));
IkReal x230=(((cj30*x213))+((sj27*x225)));
IkReal x231=(x227+(((-1.0)*cj30*x212)));
new_r00=(((r20*x220))+((r10*x230))+((r00*((x227+(((-1.0)*cj30*x212)))))));
new_r01=(((r11*x230))+((r01*x231))+((r21*x220)));
new_r02=(((r02*x231))+((r22*x220))+((r12*x230)));
new_r10=(((r00*x221))+((r10*x222))+((r20*x214)));
new_r11=(((r21*x214))+((r01*x221))+((r11*x222)));
new_r12=(((r12*x222))+((r22*x214))+((r02*x221)));
new_r20=(((r20*x226))+((r00*x229))+((r10*x228)));
new_r21=(((r01*x229))+((r11*x228))+((r21*x226)));
new_r22=(((r12*x228))+((r22*x226))+((r02*((x224+(((-1.0)*x212*x216)))))));
{
IkReal j32array[2], cj32array[2], sj32array[2];
bool j32valid[2]={false};
_nj32 = 2;
cj32array[0]=new_r22;
if( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j32valid[0] = j32valid[1] = true;
    j32array[0] = IKacos(cj32array[0]);
    sj32array[0] = IKsin(j32array[0]);
    cj32array[1] = cj32array[0];
    j32array[1] = -j32array[0];
    sj32array[1] = -sj32array[0];
}
else if( isnan(cj32array[0]) )
{
    // probably any value will work
    j32valid[0] = true;
    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;
}
for(int ij32 = 0; ij32 < 2; ++ij32)
{
if( !j32valid[ij32] )
{
    continue;
}
_ij32[0] = ij32; _ij32[1] = -1;
for(int iij32 = ij32+1; iij32 < 2; ++iij32)
{
if( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )
{
    j32valid[iij32]=false; _ij32[1] = iij32; break; 
}
}
j32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];

{
IkReal j31eval[3];
j31eval[0]=sj32;
j31eval[1]=IKsign(sj32);
j31eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  || IKabs(j31eval[2]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
j33eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal j31eval[2];
j31eval[0]=new_r12;
j31eval[1]=sj32;
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j33mul = 1;
j33=0;
j31mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].fmul = j31mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].fmul = j33mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j33mul = 1;
j33=0;
j31mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].fmul = j31mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].fmul = j33mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j31eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x232=new_r22*new_r22;
IkReal x233=((16.0)*new_r10);
IkReal x234=((16.0)*new_r01);
IkReal x235=((16.0)*new_r22);
IkReal x236=((8.0)*new_r11);
IkReal x237=((8.0)*new_r00);
IkReal x238=(x232*x233);
IkReal x239=(x232*x234);
j31eval[0]=((IKabs(((((-1.0)*x239))+x234)))+(IKabs((((new_r22*x236))+(((-1.0)*x237)))))+(IKabs(((((-1.0)*new_r22*x237))+((x232*x236)))))+(IKabs(((((-1.0)*x238))+x233)))+(IKabs(((((-1.0)*x234))+x239)))+(IKabs(((((-1.0)*x233))+x238)))+(IKabs(((((32.0)*new_r11))+(((-16.0)*new_r11*x232))+(((-1.0)*new_r00*x235)))))+(IKabs((((new_r11*x235))+(((16.0)*new_r00))+(((-32.0)*new_r00*x232))))));
if( IKabs(j31eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j31, j33]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j31evalpoly[1];
IkReal x240=new_r22*new_r22;
IkReal x241=((16.0)*new_r10);
IkReal x242=(new_r11*new_r22);
IkReal x243=(x240*x241);
IkReal x244=((((8.0)*x242))+(((-8.0)*new_r00)));
op[0]=x244;
op[1]=(x241+(((-1.0)*x243)));
op[2]=((((-32.0)*new_r00*x240))+(((16.0)*new_r00))+(((16.0)*x242)));
op[3]=(x243+(((-1.0)*x241)));
op[4]=x244;
polyroots4(op,zeror,numroots);
IkReal j31array[4], cj31array[4], sj31array[4], tempj31array[1];
int numsolutions = 0;
for(int ij31 = 0; ij31 < numroots; ++ij31)
{
IkReal htj31 = zeror[ij31];
tempj31array[0]=((2.0)*(atan(htj31)));
for(int kj31 = 0; kj31 < 1; ++kj31)
{
j31array[numsolutions] = tempj31array[kj31];
if( j31array[numsolutions] > IKPI )
{
    j31array[numsolutions]-=IK2PI;
}
else if( j31array[numsolutions] < -IKPI )
{
    j31array[numsolutions]+=IK2PI;
}
sj31array[numsolutions] = IKsin(j31array[numsolutions]);
cj31array[numsolutions] = IKcos(j31array[numsolutions]);
numsolutions++;
}
}
bool j31valid[4]={true,true,true,true};
_nj31 = 4;
for(int ij31 = 0; ij31 < numsolutions; ++ij31)
    {
if( !j31valid[ij31] )
{
    continue;
}
    j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
htj31 = IKtan(j31/2);

IkReal x245=((16.0)*new_r01);
IkReal x246=new_r22*new_r22;
IkReal x247=(new_r00*new_r22);
IkReal x248=((8.0)*x247);
IkReal x249=(new_r11*x246);
IkReal x250=(x245*x246);
IkReal x251=((8.0)*x249);
j31evalpoly[0]=((((htj31*htj31*htj31)*((x250+(((-1.0)*x245))))))+(((htj31*htj31*htj31*htj31)*((x251+(((-1.0)*x248))))))+x251+((htj31*((x245+(((-1.0)*x250))))))+(((-1.0)*x248))+(((htj31*htj31)*(((((32.0)*new_r11))+(((-16.0)*x249))+(((-16.0)*x247)))))));
if( IKabs(j31evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < numsolutions; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
{
IkReal j33eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x252=cj31*cj31;
IkReal x253=(cj31*new_r22);
IkReal x254=((-1.0)+x252+(((-1.0)*x252*(new_r22*new_r22))));
j33eval[0]=x254;
j33eval[1]=IKsign(x254);
j33eval[2]=((IKabs((((new_r01*sj31))+(((-1.0)*new_r00*x253)))))+(IKabs((((new_r01*x253))+((new_r00*sj31))))));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal j33eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j33eval[0]=new_r22;
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x255=new_r22*new_r22;
j33eval[0]=(((cj31*x255))+(((-1.0)*cj31)));
j33eval[1]=((((-1.0)*sj31))+((sj31*x255)));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x256=IKsin(j33);
IkReal x257=IKcos(j33);
evalcond[0]=x256;
evalcond[1]=((-1.0)*x257);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x256)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x257)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x258=IKsin(j33);
IkReal x259=IKcos(j33);
evalcond[0]=x258;
evalcond[1]=((-1.0)*x259);
evalcond[2]=(new_r00+(((-1.0)*x258)));
evalcond[3]=(new_r01+(((-1.0)*x259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x260=IKsin(j33);
IkReal x261=IKcos(j33);
evalcond[0]=x260;
evalcond[1]=((-1.0)*x261);
evalcond[2]=((((-1.0)*x260))+new_r10);
evalcond[3]=((((-1.0)*x261))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x262=IKsin(j33);
IkReal x263=IKcos(j33);
evalcond[0]=x262;
evalcond[1]=((-1.0)*x263);
evalcond[2]=((((-1.0)*x262))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x263))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x264=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x264.valid){
continue;
}
if((x264.value) < -0.00001)
continue;
IkReal gconst36=((-1.0)*(IKsqrt(x264.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj31)))))+(IKabs((cj31+(((-1.0)*gconst36)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
sj31=IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))));
cj31=gconst36;
if( (gconst36) < -1-IKFAST_SINCOS_THRESH || (gconst36) > 1+IKFAST_SINCOS_THRESH )
    continue;
j31=IKacos(gconst36);
CheckValue<IkReal> x265=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x265.valid){
continue;
}
if((x265.value) < -0.00001)
continue;
IkReal gconst36=((-1.0)*(IKsqrt(x265.value)));
j33eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
CheckValue<IkReal> x266=IKPowWithIntegerCheck(gconst36,-1);
if(!x266.valid){
continue;
}
if( IKabs((((gconst36*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x266.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst36*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36))))))))))+IKsqr((new_r11*(x266.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((gconst36*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36))))))))), (new_r11*(x266.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x267=IKcos(j33);
IkReal x268=IKsin(j33);
IkReal x269=((1.0)*x267);
IkReal x270=((1.0)*x268);
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
IkReal x271=IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))));
IkReal x272=((1.0)*x271);
evalcond[0]=x268;
evalcond[1]=((-1.0)*x267);
evalcond[2]=((((-1.0)*gconst36*x269))+new_r11);
evalcond[3]=((((-1.0)*gconst36*x270))+new_r10);
evalcond[4]=(new_r01+((x267*x271)));
evalcond[5]=(new_r00+((x268*x271)));
evalcond[6]=((((-1.0)*new_r00*x272))+((gconst36*new_r10))+(((-1.0)*x270)));
evalcond[7]=((((-1.0)*new_r01*x272))+((gconst36*new_r11))+(((-1.0)*x269)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x273 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x273.valid){
continue;
}
CheckValue<IkReal> x274=IKPowWithIntegerCheck(IKsign(gconst36),-1);
if(!x274.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x273.value)+(((1.5707963267949)*(x274.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x275=IKcos(j33);
IkReal x276=IKsin(j33);
IkReal x277=((1.0)*x275);
IkReal x278=((1.0)*x276);
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
IkReal x279=IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))));
IkReal x280=((1.0)*x279);
evalcond[0]=x276;
evalcond[1]=((-1.0)*x275);
evalcond[2]=((((-1.0)*gconst36*x277))+new_r11);
evalcond[3]=((((-1.0)*gconst36*x278))+new_r10);
evalcond[4]=(((x275*x279))+new_r01);
evalcond[5]=(new_r00+((x276*x279)));
evalcond[6]=((((-1.0)*new_r00*x280))+((gconst36*new_r10))+(((-1.0)*x278)));
evalcond[7]=(((gconst36*new_r11))+(((-1.0)*new_r01*x280))+(((-1.0)*x277)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x281=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x281.valid){
continue;
}
if((x281.value) < -0.00001)
continue;
IkReal gconst36=((-1.0)*(IKsqrt(x281.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj31)))))+(IKabs((cj31+(((-1.0)*gconst36)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
sj31=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))))));
cj31=gconst36;
if( (gconst36) < -1-IKFAST_SINCOS_THRESH || (gconst36) > 1+IKFAST_SINCOS_THRESH )
    continue;
j31=((-1.0)*(IKacos(gconst36)));
CheckValue<IkReal> x282=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x282.valid){
continue;
}
if((x282.value) < -0.00001)
continue;
IkReal gconst36=((-1.0)*(IKsqrt(x282.value)));
j33eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
CheckValue<IkReal> x283=IKPowWithIntegerCheck(gconst36,-1);
if(!x283.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36))))))))+((gconst36*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x283.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36))))))))+((gconst36*new_r10))))+IKsqr((new_r11*(x283.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36))))))))+((gconst36*new_r10))), (new_r11*(x283.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x284=IKcos(j33);
IkReal x285=IKsin(j33);
IkReal x286=((1.0)*x285);
IkReal x287=((1.0)*x284);
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
IkReal x288=IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))));
evalcond[0]=x285;
evalcond[1]=((-1.0)*x284);
evalcond[2]=((((-1.0)*gconst36*x287))+new_r11);
evalcond[3]=((((-1.0)*gconst36*x286))+new_r10);
evalcond[4]=((((-1.0)*x287*x288))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x286*x288)));
evalcond[6]=(((gconst36*new_r10))+(((-1.0)*x286))+((new_r00*x288)));
evalcond[7]=(((gconst36*new_r11))+(((-1.0)*x287))+((new_r01*x288)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x289 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x289.valid){
continue;
}
CheckValue<IkReal> x290=IKPowWithIntegerCheck(IKsign(gconst36),-1);
if(!x290.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x289.value)+(((1.5707963267949)*(x290.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x291=IKcos(j33);
IkReal x292=IKsin(j33);
IkReal x293=((1.0)*x292);
IkReal x294=((1.0)*x291);
if((((1.0)+(((-1.0)*(gconst36*gconst36))))) < -0.00001)
continue;
IkReal x295=IKsqrt(((1.0)+(((-1.0)*(gconst36*gconst36)))));
evalcond[0]=x292;
evalcond[1]=((-1.0)*x291);
evalcond[2]=((((-1.0)*gconst36*x294))+new_r11);
evalcond[3]=((((-1.0)*gconst36*x293))+new_r10);
evalcond[4]=(new_r01+(((-1.0)*x294*x295)));
evalcond[5]=((((-1.0)*x293*x295))+new_r00);
evalcond[6]=((((-1.0)*x293))+((new_r00*x295))+((gconst36*new_r10)));
evalcond[7]=((((-1.0)*x294))+((new_r01*x295))+((gconst36*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x296=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x296.valid){
continue;
}
if((x296.value) < -0.00001)
continue;
IkReal gconst37=IKsqrt(x296.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj31)))))+(IKabs((cj31+(((-1.0)*gconst37)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
sj31=IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))));
cj31=gconst37;
if( (gconst37) < -1-IKFAST_SINCOS_THRESH || (gconst37) > 1+IKFAST_SINCOS_THRESH )
    continue;
j31=IKacos(gconst37);
CheckValue<IkReal> x297=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x297.valid){
continue;
}
if((x297.value) < -0.00001)
continue;
IkReal gconst37=IKsqrt(x297.value);
j33eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
CheckValue<IkReal> x298=IKPowWithIntegerCheck(gconst37,-1);
if(!x298.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37))))))))+((gconst37*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x298.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37))))))))+((gconst37*new_r10))))+IKsqr((new_r11*(x298.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37))))))))+((gconst37*new_r10))), (new_r11*(x298.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x299=IKcos(j33);
IkReal x300=IKsin(j33);
IkReal x301=((1.0)*x300);
IkReal x302=((1.0)*x299);
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
IkReal x303=IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))));
IkReal x304=((1.0)*x303);
evalcond[0]=x300;
evalcond[1]=((-1.0)*x299);
evalcond[2]=(new_r11+(((-1.0)*gconst37*x302)));
evalcond[3]=(new_r10+(((-1.0)*gconst37*x301)));
evalcond[4]=(((x299*x303))+new_r01);
evalcond[5]=(new_r00+((x300*x303)));
evalcond[6]=(((gconst37*new_r10))+(((-1.0)*new_r00*x304))+(((-1.0)*x301)));
evalcond[7]=((((-1.0)*new_r01*x304))+((gconst37*new_r11))+(((-1.0)*x302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x305=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x305.valid){
continue;
}
CheckValue<IkReal> x306 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x306.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x305.value)))+(x306.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x307=IKcos(j33);
IkReal x308=IKsin(j33);
IkReal x309=((1.0)*x308);
IkReal x310=((1.0)*x307);
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
IkReal x311=IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))));
IkReal x312=((1.0)*x311);
evalcond[0]=x308;
evalcond[1]=((-1.0)*x307);
evalcond[2]=((((-1.0)*gconst37*x310))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*gconst37*x309)));
evalcond[4]=(((x307*x311))+new_r01);
evalcond[5]=(((x308*x311))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x312))+((gconst37*new_r10))+(((-1.0)*x309)));
evalcond[7]=((((-1.0)*x310))+((gconst37*new_r11))+(((-1.0)*new_r01*x312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x313=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x313.valid){
continue;
}
if((x313.value) < -0.00001)
continue;
IkReal gconst37=IKsqrt(x313.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj31)))))+(IKabs((cj31+(((-1.0)*gconst37)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
sj31=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))))));
cj31=gconst37;
if( (gconst37) < -1-IKFAST_SINCOS_THRESH || (gconst37) > 1+IKFAST_SINCOS_THRESH )
    continue;
j31=((-1.0)*(IKacos(gconst37)));
CheckValue<IkReal> x314=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x314.valid){
continue;
}
if((x314.value) < -0.00001)
continue;
IkReal gconst37=IKsqrt(x314.value);
j33eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
CheckValue<IkReal> x315=IKPowWithIntegerCheck(gconst37,-1);
if(!x315.valid){
continue;
}
if( IKabs((((gconst37*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x315.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst37*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37))))))))))+IKsqr((new_r11*(x315.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((gconst37*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37))))))))), (new_r11*(x315.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x316=IKcos(j33);
IkReal x317=IKsin(j33);
IkReal x318=((1.0)*x317);
IkReal x319=((1.0)*x316);
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
IkReal x320=IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))));
evalcond[0]=x317;
evalcond[1]=((-1.0)*x316);
evalcond[2]=((((-1.0)*gconst37*x319))+new_r11);
evalcond[3]=((((-1.0)*gconst37*x318))+new_r10);
evalcond[4]=((((-1.0)*x319*x320))+new_r01);
evalcond[5]=((((-1.0)*x318*x320))+new_r00);
evalcond[6]=(((new_r00*x320))+(((-1.0)*x318))+((gconst37*new_r10)));
evalcond[7]=(((new_r01*x320))+(((-1.0)*x319))+((gconst37*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x321=IKPowWithIntegerCheck(IKsign(gconst37),-1);
if(!x321.valid){
continue;
}
CheckValue<IkReal> x322 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x322.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x321.value)))+(x322.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x323=IKcos(j33);
IkReal x324=IKsin(j33);
IkReal x325=((1.0)*x324);
IkReal x326=((1.0)*x323);
if((((1.0)+(((-1.0)*(gconst37*gconst37))))) < -0.00001)
continue;
IkReal x327=IKsqrt(((1.0)+(((-1.0)*(gconst37*gconst37)))));
evalcond[0]=x324;
evalcond[1]=((-1.0)*x323);
evalcond[2]=((((-1.0)*gconst37*x326))+new_r11);
evalcond[3]=((((-1.0)*gconst37*x325))+new_r10);
evalcond[4]=((((-1.0)*x326*x327))+new_r01);
evalcond[5]=((((-1.0)*x325*x327))+new_r00);
evalcond[6]=(((new_r00*x327))+(((-1.0)*x325))+((gconst37*new_r10)));
evalcond[7]=(((new_r01*x327))+(((-1.0)*x326))+((gconst37*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x328=new_r22*new_r22;
CheckValue<IkReal> x329=IKPowWithIntegerCheck(((((-1.0)*cj31))+((cj31*x328))),-1);
if(!x329.valid){
continue;
}
CheckValue<IkReal> x330=IKPowWithIntegerCheck((((sj31*x328))+(((-1.0)*sj31))),-1);
if(!x330.valid){
continue;
}
if( IKabs(((x329.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x330.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x329.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x330.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((x329.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x330.value)*((((new_r10*new_r22))+new_r01))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[10];
IkReal x331=IKsin(j33);
IkReal x332=IKcos(j33);
IkReal x333=((1.0)*cj31);
IkReal x334=(new_r22*sj31);
IkReal x335=((1.0)*sj31);
IkReal x336=(cj31*new_r00);
IkReal x337=(cj31*new_r01);
IkReal x338=((1.0)*x332);
IkReal x339=(new_r22*x332);
IkReal x340=(new_r22*x331);
evalcond[0]=(((new_r11*sj31))+x337+x340);
evalcond[1]=(((new_r22*x337))+((new_r11*x334))+x331);
evalcond[2]=(((cj31*new_r10))+(((-1.0)*x331))+(((-1.0)*new_r00*x335)));
evalcond[3]=(((cj31*new_r11))+(((-1.0)*x338))+(((-1.0)*new_r01*x335)));
evalcond[4]=(((sj31*x332))+new_r01+((cj31*x340)));
evalcond[5]=((((-1.0)*new_r22*x338))+x336+((new_r10*sj31)));
evalcond[6]=(((sj31*x331))+(((-1.0)*x333*x339))+new_r00);
evalcond[7]=(((x331*x334))+(((-1.0)*x332*x333))+new_r11);
evalcond[8]=(((new_r22*x336))+((new_r10*x334))+(((-1.0)*x338)));
evalcond[9]=((((-1.0)*x331*x333))+new_r10+(((-1.0)*x334*x338)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x341=((1.0)*new_r01);
CheckValue<IkReal> x342=IKPowWithIntegerCheck(new_r22,-1);
if(!x342.valid){
continue;
}
if( IKabs(((x342.value)*(((((-1.0)*cj31*x341))+(((-1.0)*new_r11*sj31)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r11))+(((-1.0)*sj31*x341)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x342.value)*(((((-1.0)*cj31*x341))+(((-1.0)*new_r11*sj31))))))+IKsqr((((cj31*new_r11))+(((-1.0)*sj31*x341))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((x342.value)*(((((-1.0)*cj31*x341))+(((-1.0)*new_r11*sj31))))), (((cj31*new_r11))+(((-1.0)*sj31*x341))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[10];
IkReal x343=IKsin(j33);
IkReal x344=IKcos(j33);
IkReal x345=((1.0)*cj31);
IkReal x346=(new_r22*sj31);
IkReal x347=((1.0)*sj31);
IkReal x348=(cj31*new_r00);
IkReal x349=(cj31*new_r01);
IkReal x350=((1.0)*x344);
IkReal x351=(new_r22*x344);
IkReal x352=(new_r22*x343);
evalcond[0]=(((new_r11*sj31))+x352+x349);
evalcond[1]=(((new_r22*x349))+((new_r11*x346))+x343);
evalcond[2]=(((cj31*new_r10))+(((-1.0)*new_r00*x347))+(((-1.0)*x343)));
evalcond[3]=(((cj31*new_r11))+(((-1.0)*x350))+(((-1.0)*new_r01*x347)));
evalcond[4]=(((sj31*x344))+((cj31*x352))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x350))+x348+((new_r10*sj31)));
evalcond[6]=((((-1.0)*x345*x351))+((sj31*x343))+new_r00);
evalcond[7]=((((-1.0)*x344*x345))+new_r11+((x343*x346)));
evalcond[8]=(((new_r22*x348))+(((-1.0)*x350))+((new_r10*x346)));
evalcond[9]=((((-1.0)*x346*x350))+(((-1.0)*x343*x345))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x353=cj31*cj31;
IkReal x354=(cj31*new_r22);
CheckValue<IkReal> x355=IKPowWithIntegerCheck(IKsign(((-1.0)+x353+(((-1.0)*x353*(new_r22*new_r22))))),-1);
if(!x355.valid){
continue;
}
CheckValue<IkReal> x356 = IKatan2WithCheck(IkReal((((new_r01*x354))+((new_r00*sj31)))),IkReal((((new_r01*sj31))+(((-1.0)*new_r00*x354)))),IKFAST_ATAN2_MAGTHRESH);
if(!x356.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x355.value)))+(x356.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[10];
IkReal x357=IKsin(j33);
IkReal x358=IKcos(j33);
IkReal x359=((1.0)*cj31);
IkReal x360=(new_r22*sj31);
IkReal x361=((1.0)*sj31);
IkReal x362=(cj31*new_r00);
IkReal x363=(cj31*new_r01);
IkReal x364=((1.0)*x358);
IkReal x365=(new_r22*x358);
IkReal x366=(new_r22*x357);
evalcond[0]=(((new_r11*sj31))+x363+x366);
evalcond[1]=(((new_r22*x363))+x357+((new_r11*x360)));
evalcond[2]=((((-1.0)*new_r00*x361))+((cj31*new_r10))+(((-1.0)*x357)));
evalcond[3]=(((cj31*new_r11))+(((-1.0)*x364))+(((-1.0)*new_r01*x361)));
evalcond[4]=(((sj31*x358))+((cj31*x366))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x364))+x362+((new_r10*sj31)));
evalcond[6]=(((sj31*x357))+(((-1.0)*x359*x365))+new_r00);
evalcond[7]=((((-1.0)*x358*x359))+new_r11+((x357*x360)));
evalcond[8]=(((new_r22*x362))+(((-1.0)*x364))+((new_r10*x360)));
evalcond[9]=((((-1.0)*x357*x359))+(((-1.0)*x360*x364))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j31, j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x368=IKPowWithIntegerCheck(sj32,-1);
if(!x368.valid){
continue;
}
IkReal x367=x368.value;
CheckValue<IkReal> x369=IKPowWithIntegerCheck(new_r12,-1);
if(!x369.valid){
continue;
}
if( IKabs((x367*(x369.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x367)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x367*(x369.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))))+IKsqr((new_r02*x367))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2((x367*(x369.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))), (new_r02*x367));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x370=IKcos(j31);
IkReal x371=IKsin(j31);
IkReal x372=((1.0)*sj32);
IkReal x373=(new_r02*x370);
IkReal x374=(new_r12*x371);
IkReal x375=(sj32*x370);
IkReal x376=(sj32*x371);
evalcond[0]=((((-1.0)*x370*x372))+new_r02);
evalcond[1]=((((-1.0)*x371*x372))+new_r12);
evalcond[2]=(((new_r12*x370))+(((-1.0)*new_r02*x371)));
evalcond[3]=((((-1.0)*x372))+x374+x373);
evalcond[4]=(((new_r00*x375))+((cj32*new_r20))+((new_r10*x376)));
evalcond[5]=(((new_r01*x375))+((cj32*new_r21))+((new_r11*x376)));
evalcond[6]=((-1.0)+((cj32*new_r22))+((sj32*x374))+((sj32*x373)));
evalcond[7]=((((-1.0)*new_r22*x372))+((cj32*x373))+((cj32*x374)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[3];
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
j33eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
j33eval[0]=sj32;
j33eval[1]=sj31;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
j33eval[0]=cj32;
j33eval[1]=sj31;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x377=IKcos(j33);
IkReal x378=IKsin(j33);
IkReal x379=((1.0)*sj31);
IkReal x380=((1.0)*x378);
IkReal x381=((1.0)*x377);
evalcond[0]=(x377+new_r20);
evalcond[1]=((((-1.0)*x380))+new_r21);
evalcond[2]=(((sj31*x377))+new_r01);
evalcond[3]=(((sj31*x378))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj31*x381)));
evalcond[5]=(new_r10+(((-1.0)*cj31*x380)));
evalcond[6]=((((-1.0)*new_r00*x379))+((cj31*new_r10))+(((-1.0)*x380)));
evalcond[7]=(((cj31*new_r11))+(((-1.0)*x381))+(((-1.0)*new_r01*x379)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x382=IKcos(j33);
IkReal x383=IKsin(j33);
IkReal x384=((1.0)*sj31);
IkReal x385=((1.0)*x382);
IkReal x386=((1.0)*x383);
evalcond[0]=(x383+new_r21);
evalcond[1]=((((-1.0)*x385))+new_r20);
evalcond[2]=(((sj31*x382))+new_r01);
evalcond[3]=(((sj31*x383))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj31*x385)));
evalcond[5]=(new_r10+(((-1.0)*cj31*x386)));
evalcond[6]=(((cj31*new_r10))+(((-1.0)*new_r00*x384))+(((-1.0)*x386)));
evalcond[7]=(((cj31*new_r11))+(((-1.0)*new_r01*x384))+(((-1.0)*x385)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x387=IKcos(j33);
IkReal x388=IKsin(j33);
IkReal x389=((1.0)*sj32);
IkReal x390=((1.0)*x387);
evalcond[0]=(((sj32*x387))+new_r20);
evalcond[1]=((((-1.0)*x388))+new_r10);
evalcond[2]=((((-1.0)*x390))+new_r11);
evalcond[3]=(new_r01+((cj32*x388)));
evalcond[4]=(new_r21+(((-1.0)*x388*x389)));
evalcond[5]=((((-1.0)*cj32*x390))+new_r00);
evalcond[6]=(((cj32*new_r01))+x388+(((-1.0)*new_r21*x389)));
evalcond[7]=((((-1.0)*x390))+((cj32*new_r00))+(((-1.0)*new_r20*x389)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[3];
sj31=0;
cj31=-1.0;
j31=3.14159265358979;
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
j33eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal j33eval[1];
sj31=0;
cj31=-1.0;
j31=3.14159265358979;
j33eval[0]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
sj31=0;
cj31=-1.0;
j31=3.14159265358979;
j33eval[0]=cj32;
j33eval[1]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x391=IKcos(j33);
IkReal x392=((1.0)*(IKsin(j33)));
evalcond[0]=(x391+new_r20);
evalcond[1]=((((-1.0)*x392))+new_r21);
evalcond[2]=((((-1.0)*x392))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x391))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x393=IKsin(j33);
IkReal x394=((1.0)*(IKcos(j33)));
evalcond[0]=(x393+new_r21);
evalcond[1]=((((-1.0)*x394))+new_r20);
evalcond[2]=((((-1.0)*x393))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x394))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x395=IKsin(j33);
IkReal x396=((1.0)*(IKcos(j33)));
evalcond[0]=(x395+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x395))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x396))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x396))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x397=IKcos(j33);
IkReal x398=((1.0)*(IKsin(j33)));
evalcond[0]=(x397+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x398))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x397))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x398))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[6];
IkReal x399=IKsin(j33);
IkReal x400=IKcos(j33);
IkReal x401=((-1.0)*x400);
evalcond[0]=x399;
evalcond[1]=(new_r22*x399);
evalcond[2]=x401;
evalcond[3]=(new_r22*x401);
evalcond[4]=((((-1.0)*x399))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*new_r11))+(((-1.0)*x400)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x402=IKPowWithIntegerCheck(cj32,-1);
if(!x402.valid){
continue;
}
CheckValue<IkReal> x403=IKPowWithIntegerCheck(sj32,-1);
if(!x403.valid){
continue;
}
if( IKabs((new_r01*(x402.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x403.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x402.value)))+IKsqr(((-1.0)*new_r20*(x403.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r01*(x402.value)), ((-1.0)*new_r20*(x403.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x404=IKsin(j33);
IkReal x405=IKcos(j33);
IkReal x406=((1.0)*new_r00);
IkReal x407=((1.0)*sj32);
IkReal x408=((1.0)*new_r01);
IkReal x409=((1.0)*x405);
evalcond[0]=(new_r20+((sj32*x405)));
evalcond[1]=((((-1.0)*x404*x407))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x404)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x409)));
evalcond[4]=(((cj32*x404))+(((-1.0)*x408)));
evalcond[5]=((((-1.0)*cj32*x409))+(((-1.0)*x406)));
evalcond[6]=(x404+(((-1.0)*new_r21*x407))+(((-1.0)*cj32*x408)));
evalcond[7]=((((-1.0)*new_r20*x407))+(((-1.0)*cj32*x406))+(((-1.0)*x409)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x410=IKPowWithIntegerCheck(sj32,-1);
if(!x410.valid){
continue;
}
if( IKabs((new_r21*(x410.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x410.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*(x410.value)), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x411=IKsin(j33);
IkReal x412=IKcos(j33);
IkReal x413=((1.0)*new_r00);
IkReal x414=((1.0)*sj32);
IkReal x415=((1.0)*new_r01);
IkReal x416=((1.0)*x412);
evalcond[0]=(((sj32*x412))+new_r20);
evalcond[1]=((((-1.0)*x411*x414))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x411)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x416)));
evalcond[4]=(((cj32*x411))+(((-1.0)*x415)));
evalcond[5]=((((-1.0)*cj32*x416))+(((-1.0)*x413)));
evalcond[6]=(x411+(((-1.0)*new_r21*x414))+(((-1.0)*cj32*x415)));
evalcond[7]=((((-1.0)*new_r20*x414))+(((-1.0)*cj32*x413))+(((-1.0)*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x417=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x417.valid){
continue;
}
CheckValue<IkReal> x418 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x418.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x417.value)))+(x418.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x419=IKsin(j33);
IkReal x420=IKcos(j33);
IkReal x421=((1.0)*new_r00);
IkReal x422=((1.0)*sj32);
IkReal x423=((1.0)*new_r01);
IkReal x424=((1.0)*x420);
evalcond[0]=(new_r20+((sj32*x420)));
evalcond[1]=((((-1.0)*x419*x422))+new_r21);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x419)));
evalcond[3]=((((-1.0)*x424))+(((-1.0)*new_r11)));
evalcond[4]=(((cj32*x419))+(((-1.0)*x423)));
evalcond[5]=((((-1.0)*x421))+(((-1.0)*cj32*x424)));
evalcond[6]=(x419+(((-1.0)*new_r21*x422))+(((-1.0)*cj32*x423)));
evalcond[7]=((((-1.0)*x424))+(((-1.0)*new_r20*x422))+(((-1.0)*cj32*x421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x425=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x425)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x425)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x425))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x425))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x425))), (((cj31*new_r00))+(((-1.0)*new_r01*x425))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x426=IKsin(j33);
IkReal x427=IKcos(j33);
IkReal x428=((1.0)*sj31);
IkReal x429=((1.0)*x427);
IkReal x430=(sj31*x426);
IkReal x431=((1.0)*x426);
IkReal x432=(cj31*x429);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x426);
evalcond[1]=(((cj31*x426))+((sj31*x427))+new_r01);
evalcond[2]=(((cj31*new_r00))+(((-1.0)*x429))+((new_r10*sj31)));
evalcond[3]=((((-1.0)*x431))+((cj31*new_r10))+(((-1.0)*new_r00*x428)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x429))+(((-1.0)*new_r01*x428)));
evalcond[5]=((((-1.0)*x432))+x430+new_r00);
evalcond[6]=((((-1.0)*x432))+x430+new_r11);
evalcond[7]=((((-1.0)*x427*x428))+(((-1.0)*cj31*x431))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x433=((1.0)*sj31);
if( IKabs(((((-1.0)*new_r00*x433))+((cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x433)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x433))+((cj31*new_r01))))+IKsqr(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x433))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*new_r00*x433))+((cj31*new_r01))), ((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x433))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x434=IKsin(j33);
IkReal x435=IKcos(j33);
IkReal x436=((1.0)*sj31);
IkReal x437=((1.0)*x434);
IkReal x438=(sj31*x435);
IkReal x439=((1.0)*x435);
IkReal x440=(cj31*x437);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x435);
evalcond[1]=((((-1.0)*x437))+((cj31*new_r01))+((new_r11*sj31)));
evalcond[2]=(((cj31*x435))+((sj31*x434))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x436))+(((-1.0)*x437))+((cj31*new_r10)));
evalcond[4]=((((-1.0)*x439))+(((-1.0)*new_r01*x436))+((cj31*new_r11)));
evalcond[5]=((((-1.0)*x440))+x438+new_r01);
evalcond[6]=((((-1.0)*x440))+x438+new_r10);
evalcond[7]=((((-1.0)*x434*x436))+(((-1.0)*cj31*x439))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j33eval[0]=1.0;
if( IKabs(j33eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j33]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j33array[2], cj33array[2], sj33array[2], tempj33array[1];
int numsolutions = 0;
for(int ij33 = 0; ij33 < numroots; ++ij33)
{
IkReal htj33 = zeror[ij33];
tempj33array[0]=((2.0)*(atan(htj33)));
for(int kj33 = 0; kj33 < 1; ++kj33)
{
j33array[numsolutions] = tempj33array[kj33];
if( j33array[numsolutions] > IKPI )
{
    j33array[numsolutions]-=IK2PI;
}
else if( j33array[numsolutions] < -IKPI )
{
    j33array[numsolutions]+=IK2PI;
}
sj33array[numsolutions] = IKsin(j33array[numsolutions]);
cj33array[numsolutions] = IKcos(j33array[numsolutions]);
numsolutions++;
}
}
bool j33valid[2]={true,true};
_nj33 = 2;
for(int ij33 = 0; ij33 < numsolutions; ++ij33)
    {
if( !j33valid[ij33] )
{
    continue;
}
    j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
htj33 = IKtan(j33/2);

_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < numsolutions; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x442=IKPowWithIntegerCheck(sj32,-1);
if(!x442.valid){
continue;
}
IkReal x441=x442.value;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(cj32,-1);
if(!x443.valid){
continue;
}
CheckValue<IkReal> x444=IKPowWithIntegerCheck(sj31,-1);
if(!x444.valid){
continue;
}
if( IKabs((x441*(x443.value)*(x444.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x441)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x441*(x443.value)*(x444.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))))+IKsqr(((-1.0)*new_r20*x441))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x441*(x443.value)*(x444.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))), ((-1.0)*new_r20*x441));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x445=IKsin(j33);
IkReal x446=IKcos(j33);
IkReal x447=(cj31*cj32);
IkReal x448=((1.0)*sj31);
IkReal x449=(new_r11*sj31);
IkReal x450=(new_r10*sj31);
IkReal x451=((1.0)*sj32);
IkReal x452=((1.0)*x446);
IkReal x453=((1.0)*x445);
IkReal x454=(sj31*x445);
evalcond[0]=(((sj32*x446))+new_r20);
evalcond[1]=((((-1.0)*x445*x451))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x445))+x449);
evalcond[3]=((((-1.0)*new_r00*x448))+((cj31*new_r10))+(((-1.0)*x453)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x448))+(((-1.0)*x452)));
evalcond[5]=(((sj31*x446))+((x445*x447))+new_r01);
evalcond[6]=((((-1.0)*cj32*x452))+((cj31*new_r00))+x450);
evalcond[7]=((((-1.0)*x447*x452))+x454+new_r00);
evalcond[8]=(new_r11+((cj32*x454))+(((-1.0)*cj31*x452)));
evalcond[9]=(new_r10+(((-1.0)*cj32*x446*x448))+(((-1.0)*cj31*x453)));
evalcond[10]=((((-1.0)*new_r21*x451))+((new_r01*x447))+((cj32*x449))+x445);
evalcond[11]=(((new_r00*x447))+(((-1.0)*new_r20*x451))+(((-1.0)*x452))+((cj32*x450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x456=IKPowWithIntegerCheck(sj32,-1);
if(!x456.valid){
continue;
}
IkReal x455=x456.value;
CheckValue<IkReal> x457=IKPowWithIntegerCheck(sj31,-1);
if(!x457.valid){
continue;
}
if( IKabs((new_r21*x455)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x455*(x457.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x455))+IKsqr((x455*(x457.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*x455), (x455*(x457.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x458=IKsin(j33);
IkReal x459=IKcos(j33);
IkReal x460=(cj31*cj32);
IkReal x461=((1.0)*sj31);
IkReal x462=(new_r11*sj31);
IkReal x463=(new_r10*sj31);
IkReal x464=((1.0)*sj32);
IkReal x465=((1.0)*x459);
IkReal x466=((1.0)*x458);
IkReal x467=(sj31*x458);
evalcond[0]=(((sj32*x459))+new_r20);
evalcond[1]=((((-1.0)*x458*x464))+new_r21);
evalcond[2]=(((cj31*new_r01))+x462+((cj32*x458)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x466))+(((-1.0)*new_r00*x461)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x461))+(((-1.0)*x465)));
evalcond[5]=(new_r01+((x458*x460))+((sj31*x459)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x465))+x463);
evalcond[7]=((((-1.0)*x460*x465))+x467+new_r00);
evalcond[8]=(new_r11+((cj32*x467))+(((-1.0)*cj31*x465)));
evalcond[9]=((((-1.0)*cj32*x459*x461))+new_r10+(((-1.0)*cj31*x466)));
evalcond[10]=((((-1.0)*new_r21*x464))+((new_r01*x460))+x458+((cj32*x462)));
evalcond[11]=(((new_r00*x460))+(((-1.0)*new_r20*x464))+(((-1.0)*x465))+((cj32*x463)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x468=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x468.valid){
continue;
}
CheckValue<IkReal> x469 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x469.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x468.value)))+(x469.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x470=IKsin(j33);
IkReal x471=IKcos(j33);
IkReal x472=(cj31*cj32);
IkReal x473=((1.0)*sj31);
IkReal x474=(new_r11*sj31);
IkReal x475=(new_r10*sj31);
IkReal x476=((1.0)*sj32);
IkReal x477=((1.0)*x471);
IkReal x478=((1.0)*x470);
IkReal x479=(sj31*x470);
evalcond[0]=(((sj32*x471))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x470*x476)));
evalcond[2]=(((cj31*new_r01))+x474+((cj32*x470)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x473))+(((-1.0)*x478)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x477))+(((-1.0)*new_r01*x473)));
evalcond[5]=(((x470*x472))+new_r01+((sj31*x471)));
evalcond[6]=((((-1.0)*cj32*x477))+((cj31*new_r00))+x475);
evalcond[7]=((((-1.0)*x472*x477))+x479+new_r00);
evalcond[8]=((((-1.0)*cj31*x477))+((cj32*x479))+new_r11);
evalcond[9]=((((-1.0)*cj31*x478))+new_r10+(((-1.0)*cj32*x471*x473)));
evalcond[10]=((((-1.0)*new_r21*x476))+((new_r01*x472))+x470+((cj32*x474)));
evalcond[11]=((((-1.0)*x477))+((new_r00*x472))+((cj32*x475))+(((-1.0)*new_r20*x476)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x480=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x480.valid){
continue;
}
CheckValue<IkReal> x481 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x481.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x480.value)))+(x481.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[2];
evalcond[0]=(((sj32*(IKcos(j33))))+new_r20);
evalcond[1]=((((-1.0)*sj32*(IKsin(j33))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j31eval[3];
j31eval[0]=sj32;
j31eval[1]=IKsign(sj32);
j31eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  || IKabs(j31eval[2]) < 0.0000010000000000  )
{
{
IkReal j31eval[2];
j31eval[0]=cj33;
j31eval[1]=sj32;
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j33)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x482=IKsin(j31);
IkReal x483=IKcos(j31);
IkReal x484=((1.0)*new_r21);
IkReal x485=(new_r21*x482);
IkReal x486=(new_r22*x482);
IkReal x487=(new_r00*x483);
IkReal x488=(new_r02*x483);
IkReal x489=((1.0)*x482);
IkReal x490=(new_r01*x483);
IkReal x491=((1.0)*x483);
evalcond[0]=(x482+new_r00);
evalcond[1]=(new_r01+((new_r22*x483)));
evalcond[2]=(x486+new_r11);
evalcond[3]=((((-1.0)*x491))+new_r10);
evalcond[4]=((((-1.0)*x483*x484))+new_r02);
evalcond[5]=((((-1.0)*x482*x484))+new_r12);
evalcond[6]=(((new_r10*x482))+x487);
evalcond[7]=(((new_r12*x483))+(((-1.0)*new_r02*x489)));
evalcond[8]=((((-1.0)*new_r01*x489))+((new_r11*x483)));
evalcond[9]=(((new_r11*x482))+x490+new_r22);
evalcond[10]=((-1.0)+(((-1.0)*new_r00*x489))+((new_r10*x483)));
evalcond[11]=(((new_r10*x485))+((new_r21*x487)));
evalcond[12]=(((new_r10*x486))+((new_r22*x487)));
evalcond[13]=((((-1.0)*x484))+((new_r12*x482))+x488);
evalcond[14]=(((new_r11*x485))+((new_r21*x490))+((new_r21*new_r22)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((new_r21*x488))+((new_r12*x485)));
evalcond[16]=(((new_r12*x486))+(((-1.0)*new_r22*x484))+((new_r22*x488)));
evalcond[17]=((1.0)+(((-1.0)*new_r21*x484))+((new_r11*x486))+((new_r22*x490)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j33)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x492=IKcos(j31);
IkReal x493=IKsin(j31);
IkReal x494=(new_r21*new_r22);
IkReal x495=((1.0)*x492);
IkReal x496=((1.0)*x493);
IkReal x497=(new_r22*x493);
IkReal x498=(new_r22*x492);
evalcond[0]=(x492+new_r10);
evalcond[1]=(((new_r21*x492))+new_r02);
evalcond[2]=(((new_r21*x493))+new_r12);
evalcond[3]=((((-1.0)*x496))+new_r00);
evalcond[4]=((((-1.0)*new_r22*x495))+new_r01);
evalcond[5]=((((-1.0)*new_r22*x496))+new_r11);
evalcond[6]=(((new_r10*x493))+((new_r00*x492)));
evalcond[7]=((((-1.0)*new_r02*x496))+((new_r12*x492)));
evalcond[8]=(((new_r02*x492))+((new_r12*x493))+new_r21);
evalcond[9]=((((-1.0)*new_r01*x496))+((new_r11*x492)));
evalcond[10]=((1.0)+(((-1.0)*new_r00*x496))+((new_r10*x492)));
evalcond[11]=(((new_r10*x497))+((new_r00*x498)));
evalcond[12]=(((new_r11*x493))+(((-1.0)*new_r22))+((new_r01*x492)));
evalcond[13]=((((-1.0)*new_r00*new_r21*x495))+(((-1.0)*new_r10*new_r21*x496)));
evalcond[14]=(((new_r02*x498))+((new_r12*x497))+x494);
evalcond[15]=((-1.0)+(new_r21*new_r21)+((new_r11*x497))+((new_r01*x498)));
evalcond[16]=(x494+(((-1.0)*new_r01*new_r21*x495))+(((-1.0)*new_r11*new_r21*x496)));
evalcond[17]=((-1.0)+(new_r22*new_r22)+(((-1.0)*new_r12*new_r21*x496))+(((-1.0)*new_r02*new_r21*x495)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x499=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj33))+(((-1.0)*cj33*x499)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj33*new_r00))+(((-1.0)*sj33*x499)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj33))+(((-1.0)*cj33*x499))))+IKsqr((((cj33*new_r00))+(((-1.0)*sj33*x499))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2(((((-1.0)*new_r00*sj33))+(((-1.0)*cj33*x499))), (((cj33*new_r00))+(((-1.0)*sj33*x499))));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x500=IKsin(j31);
IkReal x501=IKcos(j31);
IkReal x502=((1.0)*cj33);
IkReal x503=((1.0)*sj33);
IkReal x504=(sj33*x500);
IkReal x505=((1.0)*x500);
IkReal x506=(x501*x502);
evalcond[0]=(((new_r11*x500))+sj33+((new_r01*x501)));
evalcond[1]=(((sj33*x501))+new_r01+((cj33*x500)));
evalcond[2]=((((-1.0)*x506))+x504+new_r00);
evalcond[3]=((((-1.0)*x506))+x504+new_r11);
evalcond[4]=((((-1.0)*x502))+((new_r10*x500))+((new_r00*x501)));
evalcond[5]=((((-1.0)*x501*x503))+new_r10+(((-1.0)*x500*x502)));
evalcond[6]=((((-1.0)*new_r00*x505))+(((-1.0)*x503))+((new_r10*x501)));
evalcond[7]=((((-1.0)*new_r01*x505))+(((-1.0)*x502))+((new_r11*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x507=((1.0)*cj33);
if( IKabs(((((-1.0)*new_r01*x507))+(((-1.0)*new_r00*sj33)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj33))+(((-1.0)*new_r00*x507)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x507))+(((-1.0)*new_r00*sj33))))+IKsqr((((new_r01*sj33))+(((-1.0)*new_r00*x507))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2(((((-1.0)*new_r01*x507))+(((-1.0)*new_r00*sj33))), (((new_r01*sj33))+(((-1.0)*new_r00*x507))));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x508=IKcos(j31);
IkReal x509=IKsin(j31);
IkReal x510=((1.0)*sj33);
IkReal x511=(cj33*x509);
IkReal x512=(cj33*x508);
IkReal x513=((1.0)*x509);
IkReal x514=(x508*x510);
evalcond[0]=(cj33+((new_r10*x509))+((new_r00*x508)));
evalcond[1]=(((sj33*x509))+x512+new_r00);
evalcond[2]=(x511+new_r01+(((-1.0)*x514)));
evalcond[3]=(x511+new_r10+(((-1.0)*x514)));
evalcond[4]=(((new_r11*x509))+((new_r01*x508))+(((-1.0)*x510)));
evalcond[5]=((((-1.0)*x512))+new_r11+(((-1.0)*x509*x510)));
evalcond[6]=(((new_r10*x508))+(((-1.0)*new_r00*x513))+(((-1.0)*x510)));
evalcond[7]=((((-1.0)*cj33))+((new_r11*x508))+(((-1.0)*new_r01*x513)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j31eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j31eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j31eval[0]) < 0.0000010000000000  )
{
{
IkReal j31eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j31eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j31eval[0]) < 0.0000010000000000  )
{
{
IkReal j31eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j31eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j31eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j31]

} else
{
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x516 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x516.valid){
continue;
}
IkReal x515=x516.value;
j31array[0]=((-1.0)*x515);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x515)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[5];
IkReal x517=IKsin(j31);
IkReal x518=IKcos(j31);
IkReal x519=(new_r00*x518);
IkReal x520=(new_r10*x517);
IkReal x521=((1.0)*x517);
evalcond[0]=(((new_r01*x518))+((new_r11*x517)));
evalcond[1]=(x520+x519);
evalcond[2]=(((new_r10*x518))+(((-1.0)*new_r00*x521)));
evalcond[3]=(((new_r11*x518))+(((-1.0)*new_r01*x521)));
evalcond[4]=(((new_r22*x519))+((new_r22*x520)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x523 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x523.valid){
continue;
}
IkReal x522=x523.value;
j31array[0]=((-1.0)*x522);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x522)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[5];
IkReal x524=IKcos(j31);
IkReal x525=IKsin(j31);
IkReal x526=(new_r22*x525);
IkReal x527=(new_r01*x524);
IkReal x528=((1.0)*x525);
evalcond[0]=(((new_r11*x525))+x527);
evalcond[1]=((((-1.0)*new_r00*x528))+((new_r10*x524)));
evalcond[2]=(((new_r11*x524))+(((-1.0)*new_r01*x528)));
evalcond[3]=(((new_r11*x526))+((new_r22*x527)));
evalcond[4]=(((new_r00*new_r22*x524))+((new_r10*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x530 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x530.valid){
continue;
}
IkReal x529=x530.value;
j31array[0]=((-1.0)*x529);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x529)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[5];
IkReal x531=IKcos(j31);
IkReal x532=IKsin(j31);
IkReal x533=(new_r22*x532);
IkReal x534=(new_r22*x531);
IkReal x535=((1.0)*x532);
evalcond[0]=(((new_r10*x532))+((new_r00*x531)));
evalcond[1]=((((-1.0)*new_r00*x535))+((new_r10*x531)));
evalcond[2]=(((new_r11*x531))+(((-1.0)*new_r01*x535)));
evalcond[3]=(((new_r01*x534))+((new_r11*x533)));
evalcond[4]=(((new_r10*x533))+((new_r00*x534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j31]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x537=IKPowWithIntegerCheck(sj32,-1);
if(!x537.valid){
continue;
}
IkReal x536=x537.value;
CheckValue<IkReal> x538=IKPowWithIntegerCheck(cj33,-1);
if(!x538.valid){
continue;
}
if( IKabs((x536*(x538.value)*(((((-1.0)*cj32*new_r02*sj33))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x536)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x536*(x538.value)*(((((-1.0)*cj32*new_r02*sj33))+(((-1.0)*new_r01*sj32))))))+IKsqr((new_r02*x536))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2((x536*(x538.value)*(((((-1.0)*cj32*new_r02*sj33))+(((-1.0)*new_r01*sj32))))), (new_r02*x536));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x539=IKcos(j31);
IkReal x540=IKsin(j31);
IkReal x541=((1.0)*cj33);
IkReal x542=((1.0)*sj33);
IkReal x543=(cj32*sj33);
IkReal x544=((1.0)*sj32);
IkReal x545=(new_r10*x540);
IkReal x546=(cj32*x539);
IkReal x547=(sj32*x539);
IkReal x548=(new_r11*x540);
IkReal x549=(new_r12*x540);
IkReal x550=((1.0)*x540);
evalcond[0]=((((-1.0)*x539*x544))+new_r02);
evalcond[1]=((((-1.0)*x540*x544))+new_r12);
evalcond[2]=(((new_r12*x539))+(((-1.0)*new_r02*x550)));
evalcond[3]=(((x539*x543))+((cj33*x540))+new_r01);
evalcond[4]=(((new_r02*x539))+(((-1.0)*x544))+x549);
evalcond[5]=(((new_r01*x539))+x543+x548);
evalcond[6]=((((-1.0)*x541*x546))+((sj33*x540))+new_r00);
evalcond[7]=((((-1.0)*x539*x541))+((x540*x543))+new_r11);
evalcond[8]=(((new_r10*x539))+(((-1.0)*x542))+(((-1.0)*new_r00*x550)));
evalcond[9]=(((new_r11*x539))+(((-1.0)*new_r01*x550))+(((-1.0)*x541)));
evalcond[10]=((((-1.0)*cj32*x541))+x545+((new_r00*x539)));
evalcond[11]=((((-1.0)*x539*x542))+(((-1.0)*cj32*x540*x541))+new_r10);
evalcond[12]=(((new_r00*x547))+((sj32*x545))+((cj32*new_r20)));
evalcond[13]=(((sj32*x548))+((cj32*new_r21))+((new_r01*x547)));
evalcond[14]=((-1.0)+((new_r02*x547))+((sj32*x549))+((cj32*new_r22)));
evalcond[15]=(((new_r02*x546))+(((-1.0)*new_r22*x544))+((cj32*x549)));
evalcond[16]=(((cj32*x548))+(((-1.0)*new_r21*x544))+sj33+((new_r01*x546)));
evalcond[17]=(((new_r00*x546))+((cj32*x545))+(((-1.0)*new_r20*x544))+(((-1.0)*x541)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x551=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x551.valid){
continue;
}
CheckValue<IkReal> x552 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x552.valid){
continue;
}
j31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x551.value)))+(x552.value));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x553=IKcos(j31);
IkReal x554=IKsin(j31);
IkReal x555=((1.0)*cj33);
IkReal x556=((1.0)*sj33);
IkReal x557=(cj32*sj33);
IkReal x558=((1.0)*sj32);
IkReal x559=(new_r10*x554);
IkReal x560=(cj32*x553);
IkReal x561=(sj32*x553);
IkReal x562=(new_r11*x554);
IkReal x563=(new_r12*x554);
IkReal x564=((1.0)*x554);
evalcond[0]=((((-1.0)*x553*x558))+new_r02);
evalcond[1]=((((-1.0)*x554*x558))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x564))+((new_r12*x553)));
evalcond[3]=(((cj33*x554))+new_r01+((x553*x557)));
evalcond[4]=(((new_r02*x553))+(((-1.0)*x558))+x563);
evalcond[5]=(x557+x562+((new_r01*x553)));
evalcond[6]=(((sj33*x554))+(((-1.0)*x555*x560))+new_r00);
evalcond[7]=((((-1.0)*x553*x555))+((x554*x557))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x564))+((new_r10*x553))+(((-1.0)*x556)));
evalcond[9]=(((new_r11*x553))+(((-1.0)*x555))+(((-1.0)*new_r01*x564)));
evalcond[10]=((((-1.0)*cj32*x555))+x559+((new_r00*x553)));
evalcond[11]=((((-1.0)*x553*x556))+new_r10+(((-1.0)*cj32*x554*x555)));
evalcond[12]=(((sj32*x559))+((new_r00*x561))+((cj32*new_r20)));
evalcond[13]=(((new_r01*x561))+((sj32*x562))+((cj32*new_r21)));
evalcond[14]=((-1.0)+((sj32*x563))+((new_r02*x561))+((cj32*new_r22)));
evalcond[15]=((((-1.0)*new_r22*x558))+((new_r02*x560))+((cj32*x563)));
evalcond[16]=((((-1.0)*new_r21*x558))+((new_r01*x560))+sj33+((cj32*x562)));
evalcond[17]=(((cj32*x559))+((new_r00*x560))+(((-1.0)*x555))+(((-1.0)*new_r20*x558)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x565=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x565.valid){
continue;
}
CheckValue<IkReal> x566 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x566.valid){
continue;
}
j31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x565.value)))+(x566.value));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x567=IKcos(j31);
IkReal x568=IKsin(j31);
IkReal x569=((1.0)*sj32);
IkReal x570=(new_r02*x567);
IkReal x571=(new_r12*x568);
IkReal x572=(sj32*x567);
IkReal x573=(sj32*x568);
evalcond[0]=((((-1.0)*x567*x569))+new_r02);
evalcond[1]=((((-1.0)*x568*x569))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x568))+((new_r12*x567)));
evalcond[3]=(x571+x570+(((-1.0)*x569)));
evalcond[4]=(((new_r00*x572))+((new_r10*x573))+((cj32*new_r20)));
evalcond[5]=(((new_r11*x573))+((new_r01*x572))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((sj32*x571))+((sj32*x570))+((cj32*new_r22)));
evalcond[7]=(((cj32*x571))+((cj32*x570))+(((-1.0)*new_r22*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[3];
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
j33eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
j33eval[0]=sj32;
j33eval[1]=sj31;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
j33eval[0]=cj32;
j33eval[1]=sj31;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x574=IKcos(j33);
IkReal x575=IKsin(j33);
IkReal x576=((1.0)*sj31);
IkReal x577=((1.0)*x575);
IkReal x578=((1.0)*x574);
evalcond[0]=(x574+new_r20);
evalcond[1]=((((-1.0)*x577))+new_r21);
evalcond[2]=(new_r01+((sj31*x574)));
evalcond[3]=(new_r00+((sj31*x575)));
evalcond[4]=(new_r11+(((-1.0)*cj31*x578)));
evalcond[5]=(new_r10+(((-1.0)*cj31*x577)));
evalcond[6]=(((cj31*new_r10))+(((-1.0)*x577))+(((-1.0)*new_r00*x576)));
evalcond[7]=(((cj31*new_r11))+(((-1.0)*x578))+(((-1.0)*new_r01*x576)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x579=IKcos(j33);
IkReal x580=IKsin(j33);
IkReal x581=((1.0)*sj31);
IkReal x582=((1.0)*x579);
IkReal x583=((1.0)*x580);
evalcond[0]=(x580+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x582)));
evalcond[2]=(new_r01+((sj31*x579)));
evalcond[3]=(((sj31*x580))+new_r00);
evalcond[4]=((((-1.0)*cj31*x582))+new_r11);
evalcond[5]=((((-1.0)*cj31*x583))+new_r10);
evalcond[6]=(((cj31*new_r10))+(((-1.0)*x583))+(((-1.0)*new_r00*x581)));
evalcond[7]=((((-1.0)*new_r01*x581))+((cj31*new_r11))+(((-1.0)*x582)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x584=IKcos(j33);
IkReal x585=IKsin(j33);
IkReal x586=((1.0)*sj32);
IkReal x587=((1.0)*x584);
evalcond[0]=(((sj32*x584))+new_r20);
evalcond[1]=((((-1.0)*x585))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x587)));
evalcond[3]=(((cj32*x585))+new_r01);
evalcond[4]=((((-1.0)*x585*x586))+new_r21);
evalcond[5]=((((-1.0)*cj32*x587))+new_r00);
evalcond[6]=(((cj32*new_r01))+(((-1.0)*new_r21*x586))+x585);
evalcond[7]=(((cj32*new_r00))+(((-1.0)*new_r20*x586))+(((-1.0)*x587)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[3];
sj31=0;
cj31=-1.0;
j31=3.14159265358979;
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
j33eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal j33eval[1];
sj31=0;
cj31=-1.0;
j31=3.14159265358979;
j33eval[0]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
sj31=0;
cj31=-1.0;
j31=3.14159265358979;
j33eval[0]=cj32;
j33eval[1]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x588=IKcos(j33);
IkReal x589=((1.0)*(IKsin(j33)));
evalcond[0]=(x588+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x589)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x589)));
evalcond[3]=((((-1.0)*x588))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x590=IKsin(j33);
IkReal x591=((1.0)*(IKcos(j33)));
evalcond[0]=(x590+new_r21);
evalcond[1]=((((-1.0)*x591))+new_r20);
evalcond[2]=((((-1.0)*x590))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x591))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x592=IKsin(j33);
IkReal x593=((1.0)*(IKcos(j33)));
evalcond[0]=(x592+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x592))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x593))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x593))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x594=IKcos(j33);
IkReal x595=((1.0)*(IKsin(j33)));
evalcond[0]=(x594+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x595))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x594))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x595))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[6];
IkReal x596=IKsin(j33);
IkReal x597=IKcos(j33);
IkReal x598=((-1.0)*x597);
evalcond[0]=x596;
evalcond[1]=(new_r22*x596);
evalcond[2]=x598;
evalcond[3]=(new_r22*x598);
evalcond[4]=((((-1.0)*x596))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x597))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x599=IKPowWithIntegerCheck(cj32,-1);
if(!x599.valid){
continue;
}
CheckValue<IkReal> x600=IKPowWithIntegerCheck(sj32,-1);
if(!x600.valid){
continue;
}
if( IKabs((new_r01*(x599.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x600.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x599.value)))+IKsqr(((-1.0)*new_r20*(x600.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r01*(x599.value)), ((-1.0)*new_r20*(x600.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x601=IKsin(j33);
IkReal x602=IKcos(j33);
IkReal x603=((1.0)*new_r00);
IkReal x604=((1.0)*sj32);
IkReal x605=((1.0)*new_r01);
IkReal x606=((1.0)*x602);
evalcond[0]=(((sj32*x602))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x601*x604)));
evalcond[2]=((((-1.0)*x601))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x606)));
evalcond[4]=(((cj32*x601))+(((-1.0)*x605)));
evalcond[5]=((((-1.0)*cj32*x606))+(((-1.0)*x603)));
evalcond[6]=((((-1.0)*cj32*x605))+x601+(((-1.0)*new_r21*x604)));
evalcond[7]=((((-1.0)*new_r20*x604))+(((-1.0)*cj32*x603))+(((-1.0)*x606)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x607=IKPowWithIntegerCheck(sj32,-1);
if(!x607.valid){
continue;
}
if( IKabs((new_r21*(x607.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x607.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*(x607.value)), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x608=IKsin(j33);
IkReal x609=IKcos(j33);
IkReal x610=((1.0)*new_r00);
IkReal x611=((1.0)*sj32);
IkReal x612=((1.0)*new_r01);
IkReal x613=((1.0)*x609);
evalcond[0]=(((sj32*x609))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x608*x611)));
evalcond[2]=((((-1.0)*x608))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x613))+(((-1.0)*new_r11)));
evalcond[4]=(((cj32*x608))+(((-1.0)*x612)));
evalcond[5]=((((-1.0)*cj32*x613))+(((-1.0)*x610)));
evalcond[6]=((((-1.0)*new_r21*x611))+(((-1.0)*cj32*x612))+x608);
evalcond[7]=((((-1.0)*cj32*x610))+(((-1.0)*x613))+(((-1.0)*new_r20*x611)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x614=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x614.valid){
continue;
}
CheckValue<IkReal> x615 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x615.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x614.value)))+(x615.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x616=IKsin(j33);
IkReal x617=IKcos(j33);
IkReal x618=((1.0)*new_r00);
IkReal x619=((1.0)*sj32);
IkReal x620=((1.0)*new_r01);
IkReal x621=((1.0)*x617);
evalcond[0]=(((sj32*x617))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x616*x619)));
evalcond[2]=((((-1.0)*x616))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x621))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x620))+((cj32*x616)));
evalcond[5]=((((-1.0)*cj32*x621))+(((-1.0)*x618)));
evalcond[6]=((((-1.0)*new_r21*x619))+(((-1.0)*cj32*x620))+x616);
evalcond[7]=((((-1.0)*x621))+(((-1.0)*cj32*x618))+(((-1.0)*new_r20*x619)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x622=((1.0)*sj31);
if( IKabs(((((-1.0)*new_r00*x622))+(((-1.0)*cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x622))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x622))+(((-1.0)*cj31*new_r01))))+IKsqr(((((-1.0)*new_r01*x622))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*new_r00*x622))+(((-1.0)*cj31*new_r01))), ((((-1.0)*new_r01*x622))+((cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x623=IKsin(j33);
IkReal x624=IKcos(j33);
IkReal x625=((1.0)*sj31);
IkReal x626=((1.0)*x624);
IkReal x627=(sj31*x623);
IkReal x628=((1.0)*x623);
IkReal x629=(cj31*x626);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x623);
evalcond[1]=(((sj31*x624))+((cj31*x623))+new_r01);
evalcond[2]=(((cj31*new_r00))+(((-1.0)*x626))+((new_r10*sj31)));
evalcond[3]=((((-1.0)*new_r00*x625))+((cj31*new_r10))+(((-1.0)*x628)));
evalcond[4]=((((-1.0)*new_r01*x625))+((cj31*new_r11))+(((-1.0)*x626)));
evalcond[5]=((((-1.0)*x629))+x627+new_r00);
evalcond[6]=((((-1.0)*x629))+x627+new_r11);
evalcond[7]=((((-1.0)*x624*x625))+new_r10+(((-1.0)*cj31*x628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x630=((1.0)*sj31);
if( IKabs(((((-1.0)*new_r00*x630))+((cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x630))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x630))+((cj31*new_r01))))+IKsqr(((((-1.0)*new_r01*x630))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*new_r00*x630))+((cj31*new_r01))), ((((-1.0)*new_r01*x630))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x631=IKsin(j33);
IkReal x632=IKcos(j33);
IkReal x633=((1.0)*sj31);
IkReal x634=((1.0)*x631);
IkReal x635=(sj31*x632);
IkReal x636=((1.0)*x632);
IkReal x637=(cj31*x634);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x632);
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x634))+((new_r11*sj31)));
evalcond[2]=(((sj31*x631))+((cj31*x632))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x633))+(((-1.0)*x634)));
evalcond[4]=((((-1.0)*new_r01*x633))+((cj31*new_r11))+(((-1.0)*x636)));
evalcond[5]=((((-1.0)*x637))+x635+new_r01);
evalcond[6]=((((-1.0)*x637))+x635+new_r10);
evalcond[7]=((((-1.0)*x631*x633))+(((-1.0)*cj31*x636))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j33eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j33eval[0]=1.0;
if( IKabs(j33eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j33]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j33array[2], cj33array[2], sj33array[2], tempj33array[1];
int numsolutions = 0;
for(int ij33 = 0; ij33 < numroots; ++ij33)
{
IkReal htj33 = zeror[ij33];
tempj33array[0]=((2.0)*(atan(htj33)));
for(int kj33 = 0; kj33 < 1; ++kj33)
{
j33array[numsolutions] = tempj33array[kj33];
if( j33array[numsolutions] > IKPI )
{
    j33array[numsolutions]-=IK2PI;
}
else if( j33array[numsolutions] < -IKPI )
{
    j33array[numsolutions]+=IK2PI;
}
sj33array[numsolutions] = IKsin(j33array[numsolutions]);
cj33array[numsolutions] = IKcos(j33array[numsolutions]);
numsolutions++;
}
}
bool j33valid[2]={true,true};
_nj33 = 2;
for(int ij33 = 0; ij33 < numsolutions; ++ij33)
    {
if( !j33valid[ij33] )
{
    continue;
}
    j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
htj33 = IKtan(j33/2);

_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < numsolutions; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x639=IKPowWithIntegerCheck(sj32,-1);
if(!x639.valid){
continue;
}
IkReal x638=x639.value;
CheckValue<IkReal> x640=IKPowWithIntegerCheck(cj32,-1);
if(!x640.valid){
continue;
}
CheckValue<IkReal> x641=IKPowWithIntegerCheck(sj31,-1);
if(!x641.valid){
continue;
}
if( IKabs((x638*(x640.value)*(x641.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x638)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x638*(x640.value)*(x641.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))))+IKsqr(((-1.0)*new_r20*x638))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x638*(x640.value)*(x641.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))), ((-1.0)*new_r20*x638));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x642=IKsin(j33);
IkReal x643=IKcos(j33);
IkReal x644=(cj31*cj32);
IkReal x645=((1.0)*sj31);
IkReal x646=(new_r11*sj31);
IkReal x647=(new_r10*sj31);
IkReal x648=((1.0)*sj32);
IkReal x649=((1.0)*x643);
IkReal x650=((1.0)*x642);
IkReal x651=(sj31*x642);
evalcond[0]=(new_r20+((sj32*x643)));
evalcond[1]=((((-1.0)*x642*x648))+new_r21);
evalcond[2]=(((cj32*x642))+((cj31*new_r01))+x646);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x650))+(((-1.0)*new_r00*x645)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x649))+(((-1.0)*new_r01*x645)));
evalcond[5]=(((sj31*x643))+new_r01+((x642*x644)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x649))+x647);
evalcond[7]=((((-1.0)*x644*x649))+x651+new_r00);
evalcond[8]=(((cj32*x651))+new_r11+(((-1.0)*cj31*x649)));
evalcond[9]=((((-1.0)*cj32*x643*x645))+(((-1.0)*cj31*x650))+new_r10);
evalcond[10]=(((cj32*x646))+(((-1.0)*new_r21*x648))+((new_r01*x644))+x642);
evalcond[11]=(((cj32*x647))+(((-1.0)*x649))+((new_r00*x644))+(((-1.0)*new_r20*x648)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x653=IKPowWithIntegerCheck(sj32,-1);
if(!x653.valid){
continue;
}
IkReal x652=x653.value;
CheckValue<IkReal> x654=IKPowWithIntegerCheck(sj31,-1);
if(!x654.valid){
continue;
}
if( IKabs((new_r21*x652)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x652*(x654.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x652))+IKsqr((x652*(x654.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*x652), (x652*(x654.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x655=IKsin(j33);
IkReal x656=IKcos(j33);
IkReal x657=(cj31*cj32);
IkReal x658=((1.0)*sj31);
IkReal x659=(new_r11*sj31);
IkReal x660=(new_r10*sj31);
IkReal x661=((1.0)*sj32);
IkReal x662=((1.0)*x656);
IkReal x663=((1.0)*x655);
IkReal x664=(sj31*x655);
evalcond[0]=(new_r20+((sj32*x656)));
evalcond[1]=((((-1.0)*x655*x661))+new_r21);
evalcond[2]=(((cj32*x655))+((cj31*new_r01))+x659);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x658))+(((-1.0)*x663)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x658))+(((-1.0)*x662)));
evalcond[5]=(((sj31*x656))+((x655*x657))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x662))+x660);
evalcond[7]=((((-1.0)*x657*x662))+x664+new_r00);
evalcond[8]=((((-1.0)*cj31*x662))+((cj32*x664))+new_r11);
evalcond[9]=((((-1.0)*cj31*x663))+(((-1.0)*cj32*x656*x658))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x661))+((cj32*x659))+((new_r01*x657))+x655);
evalcond[11]=(((cj32*x660))+(((-1.0)*x662))+((new_r00*x657))+(((-1.0)*new_r20*x661)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x665.valid){
continue;
}
CheckValue<IkReal> x666 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x666.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x665.value)))+(x666.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x667=IKsin(j33);
IkReal x668=IKcos(j33);
IkReal x669=(cj31*cj32);
IkReal x670=((1.0)*sj31);
IkReal x671=(new_r11*sj31);
IkReal x672=(new_r10*sj31);
IkReal x673=((1.0)*sj32);
IkReal x674=((1.0)*x668);
IkReal x675=((1.0)*x667);
IkReal x676=(sj31*x667);
evalcond[0]=(((sj32*x668))+new_r20);
evalcond[1]=((((-1.0)*x667*x673))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x667))+x671);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x670))+(((-1.0)*x675)));
evalcond[4]=((((-1.0)*new_r01*x670))+((cj31*new_r11))+(((-1.0)*x674)));
evalcond[5]=(((x667*x669))+((sj31*x668))+new_r01);
evalcond[6]=(((cj31*new_r00))+x672+(((-1.0)*cj32*x674)));
evalcond[7]=((((-1.0)*x669*x674))+x676+new_r00);
evalcond[8]=((((-1.0)*cj31*x674))+((cj32*x676))+new_r11);
evalcond[9]=((((-1.0)*cj32*x668*x670))+(((-1.0)*cj31*x675))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x673))+x667+((cj32*x671))+((new_r01*x669)));
evalcond[11]=((((-1.0)*new_r20*x673))+((cj32*x672))+((new_r00*x669))+(((-1.0)*x674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return ""; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

//// START
static PyObject *right_arm_ik(PyObject *self, PyObject *args) {
    IkSolutionList<IkReal> solutions;

    // Should only have two free parameters (torso and upper arm)
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9], eetrans[3];


    // First list if 3x3 rotation matrix, easier to compute in Python.
    // Next list is [x, y, z] translation matrix.
    // Last list is free joints (torso and upper arm roll (in that order)).
    PyObject *rotList; // 3x3 rotation matrix
    PyObject *transList; // [x,y,z]
    PyObject *freeList; // [torso, upper arm]

    if(!PyArg_ParseTuple(args, "O!O!O!", &PyList_Type, &rotList, &PyList_Type, &transList, &PyList_Type, &freeList)) {
        return NULL;
    }

    for(std::size_t i = 0; i < 3; ++i) {
        eetrans[i] = PyFloat_AsDouble(PyList_GetItem(transList, i));

        PyObject* rowList = PyList_GetItem(rotList, i);
        for( std::size_t j = 0; j < 3; ++j){
            eerot[3*i + j] = PyFloat_AsDouble(PyList_GetItem(rowList, j));
        }
    }

    for(int i = 0; i < GetNumFreeParameters(); ++i) {
        vfree[i] = PyFloat_AsDouble(PyList_GetItem(freeList, i));
    }

    // I don't understand why we pass &vfree[0] instead of just vfree.
    // Clearly ComputeIk takes an IkReal* parameter there, but it treats that parameter like an array.
    // It probably does work because the computeIk call in main specifically makes this change.
    // So it's hopefully right, and I don't understand because I don't know C++.
    bool bSuccess = ComputeIk(eetrans, eerot, &vfree[0], solutions);

    if (!bSuccess) {
        return Py_BuildValue(""); // Equivalent to returning None
    }

    // There are 8 joints in each solution (torso + 7 arm joints).
    std::vector<IkReal> solvalues(GetNumJoints());
    PyObject *solutionList = PyList_New(solutions.GetNumSolutions());

    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);

        PyObject *individualSolution = PyList_New(GetNumJoints());
        for( std::size_t j = 0; j < solvalues.size(); ++j){
            // I think IkReal is just a wrapper for double. So this should work.
            PyList_SetItem(individualSolution, j, PyFloat_FromDouble(solvalues[j]));
        }
        PyList_SetItem(solutionList, i, individualSolution);
    }
    return solutionList;
}

static PyObject *right_arm_fk(PyObject *self, PyObject *args) {
    std::vector<IkReal> joints(8);
    IkReal eerot[9], eetrans[3];

    // First double is torso height. Next 7 doubles are arm joints
    PyObject *jointList;
    if(!PyArg_ParseTuple(args, "O!", &PyList_Type, &jointList)) {
        return NULL;
    }

    for(std::size_t i = 0; i < 8; ++i){
        joints[i] = PyFloat_AsDouble(PyList_GetItem(jointList, i));
    }

    ComputeFk(&joints[0], eetrans, eerot);

    PyObject *pose = PyList_New(2);
    PyObject *pos = PyList_New(3);
    PyObject *rot = PyList_New(3);

    for(std::size_t i = 0; i < 3; ++i) {
        PyList_SetItem(pos, i, PyFloat_FromDouble(eetrans[i]));

        PyObject *row = PyList_New(3);
        for( std::size_t j = 0; j < 3; ++j){
            PyList_SetItem(row, j, PyFloat_FromDouble(eerot[3*i + j]));
        }
        PyList_SetItem(rot, i, row);
    }

    PyList_SetItem(pose, 0, pos);
    PyList_SetItem(pose, 1, rot);

    return pose;
}

static PyMethodDef ikRightMethods[] = {
    {"rightIK", right_arm_ik, METH_VARARGS, "Compute IK for the PR2's right arm."},
    {"rightFK", right_arm_fk, METH_VARARGS, "Compute FK for the PR2's right arm."},
    {NULL, NULL, 0, NULL} // Not sure why/if this is needed. It shows up in the examples though(something about Sentinel).
};

#if PY_MAJOR_VERSION >= 3

//// This is the python3.4 version.
static struct PyModuleDef ikRightModule = {
    PyModuleDef_HEAD_INIT,
    "ikRight",
    NULL,
    -1,
    ikRightMethods
};

PyMODINIT_FUNC PyInit_ikRight(void) {
    return PyModule_Create(&ikRightModule);
}

#else

//// This is the python2.7 version.
PyMODINIT_FUNC initikRight(void) {
    (void) Py_InitModule("ikRight", ikRightMethods);
}

#endif

//// END
